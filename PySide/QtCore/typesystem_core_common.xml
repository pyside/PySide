<?xml version="1.0"?>
<!--
    This file is part of PySide project.
    Copyright (C) 2009-2011 Nokia Corporation and/or its subsidiary(-ies).
    Contact: PySide team <contact@pyside.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-->
<typesystem package="PySide.QtCore">
    <load-typesystem name="typesystem_templates.xml" generate="no"/>

    <custom-type name="str" />
    <custom-type name="PyBytes" />
    <custom-type name="PyCallable" />
    <custom-type name="PyObject" />
    <custom-type name="PySequence" />
    <custom-type name="PyTypeObject" />
    <custom-type name="PyUnicode" />
    <custom-type name="list of QAbstractAnimation" />
    <custom-type name="list of QAbstractState" />

    <function signature="qAcos(qreal)" />
    <function signature="qAsin(qreal)" since="4.6" />
    <function signature="qAtan(qreal)" since="4.6" />
    <function signature="qAtan2(qreal,qreal)" since="4.6" />
    <function signature="qChecksum(const char*,uint)" />
    <function signature="qExp(qreal)" since="4.6" />
    <function signature="qFabs(qreal)" since="4.6" />
    <function signature="qFastCos(qreal)" since="4.6"/>
    <function signature="qFastSin(qreal)" since="4.6" />
    <function signature="qFuzzyCompare(double,double)" />
    <function signature="qFuzzyIsNull(double)" since="4.6" />
    <function signature="qIsFinite(double)" />
    <function signature="qIsInf(double)" />
    <function signature="qIsNaN(double)" />
    <function signature="qIsNull(double)" />
    <function signature="qRound(qreal)" />
    <function signature="qTan(qreal)" since="4.6" />
    <function signature="qtTrId(const char *, int)" since="4.6" />
    <function signature="qVersion()" />
    <function signature="qrand()" />
    <function signature="qsrand(uint)" />

    <template name="use_stream_for_format_security">
        // Uses the stream version for security reasons
        // see gcc man page at -Wformat-security
        %FUNCTION_NAME() &lt;&lt; %1;
    </template>

    <add-function signature="qDebug(const char*)">
        <inject-code>
            <insert-template name="use_stream_for_format_security" />
        </inject-code>
    </add-function>
    <add-function signature="qCritical(const char*)">
        <inject-code>
            <insert-template name="use_stream_for_format_security" />
        </inject-code>
    </add-function>
    <add-function signature="qFatal(const char*)">
        <inject-code>
            // qFatal doesn't have a stream version, so we do a
            // qWarning call followed by a qFatal() call using a
            // literal.
            qWarning() &lt;&lt; %1;
            qFatal("[A qFatal() call was made from Python code]");
        </inject-code>
    </add-function>
    <add-function signature="qWarning(const char*)">
        <inject-code>
            <insert-template name="use_stream_for_format_security" />
        </inject-code>
    </add-function>

    <!-- TODO: We do not support void* or const void* as arg -->
    <rejection class="QMetaObject" function-name="activate"/>
    <rejection class="QMetaObject" function-name="metacall"/>
    <rejection class="QMetaObject" function-name="static_metacall"/>
    <!-- TODO: Support to addGuard(QObject**) -->
    <rejection class="QMetaObject" function-name="addGuard"/>
    <rejection class="QMetaObject" function-name="changeGuard"/>
    <rejection class="QMetaObject" function-name="removeGuard"/>

  <rejection class="QChildEvent" field-name="c"/>
  <rejection class="QTimerEvent" field-name="id"/>
  <rejection class="QEvent" field-name="t"/>
  <rejection class="*" function-name="tr" />
  <rejection class="*" function-name="trUtf8" />
  <rejection class="*" function-name="qt_metacast" />
  <!-- From Qt4.6 -->
  <rejection class="*" field-name="d_ptr"/>
  <rejection class="*" field-name="staticQtMetaObject"/>
  <rejection class="*" function-name="qobject_interface_iid"/>
  <rejection class="*" function-name="qGetPtrHelper"/>
  <rejection class="*" function-name="q_check_ptr"/>
  <rejection class="*" function-name="qobject_interface_iid&lt;QTextCodecFactoryInterface*&gt;"/>
  <rejection class="*" function-name="qobject_interface_iid&lt;QFactoryInterface*&gt;"/>
  <rejection class="*" function-name="qRegisterAnimationInterpolator"/>
  <rejection class="*" function-name="qvariant_cast&lt;QVariant&gt;"/>
  <rejection class="*" function-name="qVariantSetValue&lt;QVariant&gt;"/>
  <rejection class="*" function-name="qReallocAligned"/>
  <rejection class="*" function-name="qMallocAligned"/>
  <rejection class="*" function-name="qFreeAligned"/>
  <rejection class="QMetaMethod" enum-name="Attributes" />

  <enum-type name="QtValidLicenseForOpenVGModule"/>
  <enum-type name="QtValidLicenseForMultimediaModule"/>
  <enum-type name="QtValidLicenseForDeclarativeModule" />
  <!-- From Qt4.6 ^^^ -->


  <enum-type name="QtMsgType"/>

  <primitive-type name="qint8"/>
  <primitive-type name="qint16"/>
  <primitive-type name="qint32"/>
  <primitive-type name="quint8"/>
  <primitive-type name="quint16"/>
  <primitive-type name="quint32"/>
  <primitive-type name="quint64"/>
  <primitive-type name="bool"/>
  <primitive-type name="double"/>
  <primitive-type name="qreal"/>
  <primitive-type name="float"/>
  <primitive-type name="qint64"/>
  <primitive-type name="unsigned long long"/>
  <primitive-type name="long long"/>
  <primitive-type name="qlonglong" target-lang-api-name="PyLong" />
  <primitive-type name="qulonglong" target-lang-api-name="PyLong" />
  <primitive-type name="short"/>
  <primitive-type name="signed short"/>
  <primitive-type name="signed short int"/>
  <primitive-type name="ushort" target-lang-api-name="PyInt" />
  <primitive-type name="unsigned short int" />
  <primitive-type name="unsigned short"/>
  <primitive-type name="char"/>
  <primitive-type name="signed char"/>
  <primitive-type name="uchar"/>
  <primitive-type name="unsigned char"/>
  <primitive-type name="int"/>
  <primitive-type name="signed int"/>
  <primitive-type name="uint"/>
  <primitive-type name="ulong"/>
  <primitive-type name="unsigned int"/>
  <primitive-type name="signed long"/>
  <primitive-type name="signed long int"/>
  <primitive-type name="long"/>
  <primitive-type name="unsigned long int" />
  <primitive-type name="unsigned long">
    <!-- FIXME APIExtractor or shiboken do not support multiple includes by primitive type -->
    <include file-name="signalmanager.h" location="global"/>
  </primitive-type>
  <primitive-type name="QBool" target-lang-api-name="PyBool">
    <conversion-rule>
        <native-to-target>
        return PyBool_FromLong((bool)%in);
        </native-to-target>
        <target-to-native>
            <add-conversion type="PyBool">
            %out = %OUTTYPE(%in == Py_True);
            </add-conversion>
        </target-to-native>
    </conversion-rule>
    <!-- FIXME This is a workaround to include some headers needed by some includes (nothing to do with QBool) -->
    <include file-name="QtConcurrentFilter" location="global"/>
  </primitive-type>

  <inject-code class="native" position="beginning">
    bool py2kStrCheck(PyObject* obj)
    {
    #ifdef IS_PY3K
        return false;
    #else
        return PyString_Check(obj);
    #endif
    }
  </inject-code>

  <primitive-type name="QString" target-lang-api-name="PyUnicode">
    <include file-name="QString" location="global"/>
    <conversion-rule>
        <native-to-target>
        const int N = %in.length();
        wchar_t* str = new wchar_t[N];
        %in.toWCharArray(str);
        PyObject* %out = PyUnicode_FromWideChar(str, N);
        delete[] str;
        return %out;
        </native-to-target>
        <target-to-native>
            <add-conversion type="PyUnicode">
            Py_UNICODE* unicode = PyUnicode_AS_UNICODE(%in);
            #if defined(Py_UNICODE_WIDE)
            // cast as Py_UNICODE can be a different type
            %out = QString::fromUcs4((const uint*)unicode);
            #else
            %out = QString::fromUtf16(unicode, PyUnicode_GET_SIZE(%in));
            #endif
            </add-conversion>
            <add-conversion type="PyString" check="py2kStrCheck(%in)">
            #ifndef IS_PY3K
            const char* str = %CONVERTTOCPP[const char*](%in);
            %out = %OUTTYPE(str);
            #endif
            </add-conversion>
            <add-conversion type="Py_None">
            %out = %OUTTYPE();
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </primitive-type>

  <primitive-type name="QStringRef">
    <conversion-rule>
        <native-to-target>
        const int N = %in.toString().length();
        wchar_t* str = new wchar_t[N];
        %in.toString().toWCharArray(str);
        PyObject* %out = PyUnicode_FromWideChar(str, N);
        delete[] str;
        return %out;
        </native-to-target>
        <target-to-native>
            <add-conversion type="PyObject" check="Shiboken::String::check(%in) || %in == Py_None">
            %out = %OUTTYPE();
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </primitive-type>
  <primitive-type name="QChar">
    <conversion-rule>
        <native-to-target>
        wchar_t c = (wchar_t)%in.unicode();
        return PyUnicode_FromWideChar(&amp;c, 1);
        </native-to-target>
        <target-to-native>
            <add-conversion type="PyString" check="Shiboken::String::checkChar(%in)">
            char c = %CONVERTTOCPP[char](%in);
            %out = %OUTTYPE(c);
            </add-conversion>
            <add-conversion type="PyInt">
            int i = %CONVERTTOCPP[int](%in);
            %out = %OUTTYPE(i);
            </add-conversion>
            <add-conversion type="Py_None">
            %out = %OUTTYPE();
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </primitive-type>

  <primitive-type name="QVariant" target-lang-api-name="PyObject">
    <include file-name="typeresolver.h" location="global"/>
    <conversion-rule>
        <native-to-target>
        if (!%in.isValid())
            Py_RETURN_NONE;

        if (qstrcmp(%in.typeName(), "QVariantList") == 0) {
            QList&lt;QVariant&gt; var = %in.value&lt;QVariantList&gt;();
            return %CONVERTTOPYTHON[QList&lt;QVariant&gt;](var);
        }

        if (qstrcmp(%in.typeName(), "QStringList") == 0) {
            QStringList var = %in.value&lt;QStringList&gt;();
            return %CONVERTTOPYTHON[QList&lt;QString&gt;](var);
        }

        if (qstrcmp(%in.typeName(), "QVariantMap") == 0) {
            QMap&lt;QString, QVariant&gt; var = %in.value&lt;QVariantMap&gt;();
            return %CONVERTTOPYTHON[QMap&lt;QString, QVariant&gt;](var);
        }

        Shiboken::Conversions::SpecificConverter converter(cppInRef.typeName());
        if (converter) {
           void* ptr = cppInRef.data();
           return converter.toPython(ptr);
        }
        PyErr_Format(PyExc_RuntimeError, "Can't find converter for '%s'.", %in.typeName());
        return 0;
        </native-to-target>
        <target-to-native>
            <add-conversion type="PyBool">
            %out = %OUTTYPE(%in == Py_True);
            </add-conversion>
            <add-conversion type="Py_None">
            %out = %OUTTYPE();
            </add-conversion>
            <add-conversion type="QString" check="Shiboken::String::check(%in)">
            QString in = %CONVERTTOCPP[QString](%in);
            %out = %OUTTYPE(in);
            </add-conversion>
            <add-conversion type="QByteArray">
            QByteArray in = %CONVERTTOCPP[QByteArray](%in);
            %out = %OUTTYPE(in);
            </add-conversion>
            <add-conversion type="PyFloat" check="PyFloat_CheckExact(%in)">
            double in = %CONVERTTOCPP[double](%in);
            %out = %OUTTYPE(in);
            </add-conversion>
            <add-conversion type="PyInt">
            int in = %CONVERTTOCPP[int](%in);
            %out = %OUTTYPE(in);
            </add-conversion>
            <add-conversion type="PyLong" check="PyLong_CheckExact(%in)">
            qlonglong in = %CONVERTTOCPP[qlonglong](%in);
            %out = %OUTTYPE(in);
            </add-conversion>
            <add-conversion type="SbkEnumType">
            int in = %CONVERTTOCPP[int](%in);
            %out = %OUTTYPE(in);
            </add-conversion>
            <add-conversion type="SbkObject">
            // a class supported by QVariant?
            int typeCode;
            const char* typeName = QVariant_resolveMetaType(%in->ob_type, &amp;typeCode);
            if (!typeCode || !typeName)
                return;
            QVariant var(typeCode, (void*)0);
            Shiboken::Conversions::SpecificConverter converter(typeName);
            converter.toCpp(pyIn, var.data());
            %out = var;
            </add-conversion>
            <add-conversion type="PyDict">
            QVariant ret = QVariant_convertToVariantMap(%in);
            %out = ret.isValid() ? ret : QVariant::fromValue&lt;PySide::PyObjectWrapper&gt;(%in);
            </add-conversion>
            <add-conversion type="PySequence">
            %out = QVariant_convertToVariantList(%in);
            </add-conversion>
            <add-conversion type="PyObject">
            // Is a shiboken type not known by Qt
            %out = QVariant::fromValue&lt;PySide::PyObjectWrapper&gt;(%in);
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </primitive-type>
    <inject-code class="native" position="beginning">
    static const char* QVariant_resolveMetaType(PyTypeObject* type, int* typeId)
    {
        if (PyObject_TypeCheck(type, &amp;SbkObjectType_Type)) {
            SbkObjectType* sbkType = (SbkObjectType*)type;
            const char* typeName = Shiboken::ObjectType::getOriginalName(sbkType);
            if (!typeName)
                return 0;
            bool valueType = '*' != typeName[qstrlen(typeName) - 1];
            // Do not convert user type of value
            if (valueType &amp;&mp; Shiboken::ObjectType::isUserType(type))
                return 0;
            int obTypeId = QMetaType::type(typeName);
            if (obTypeId) {
                *typeId = obTypeId;
                return typeName;
            }
            // Do not resolve types to value type
            if (valueType)
                return 0;
            // find in base types
            if (type->tp_base) {
                return QVariant_resolveMetaType(type->tp_base, typeId);
            } else if (type->tp_bases) {
                for(int i = 0; i &lt; PyTuple_GET_SIZE(type->tp_bases); ++i) {
                    const char* derivedName = QVariant_resolveMetaType((PyTypeObject*)PyTuple_GET_ITEM(type->tp_bases, i), typeId);
                    if (derivedName)
                        return derivedName;
                }
            }
        }
        *typeId = 0;
        return 0;
    }
    static QVariant QVariant_convertToValueList(PyObject* list)
    {
        if (PySequence_Size(list) &lt; 1)
            return QVariant();
        Shiboken::AutoDecRef element(PySequence_GetItem(list, 0));
        int typeId;
        const char* typeName = QVariant_resolveMetaType(element.cast&lt;PyTypeObject*&gt;(), &amp;typeId);
        if (typeName) {
            QByteArray listTypeName("QList&lt;");
            listTypeName += typeName;
            listTypeName += '>';
            typeId = QMetaType::type(listTypeName);
            if (typeId &gt; 0) {
                Shiboken::Conversions::SpecificConverter converter(listTypeName);
                if (converter) {
                    QVariant var(typeId, (void*)0);
                    converter.toCpp(list, &amp;var);
                    return var;
                }
                qWarning() &lt;&lt; "Type converter for :" &lt;&lt; listTypeName &lt;&lt; "not registered.";
            }
        }
        return QVariant();
    }
    static bool QVariant_isStringList(PyObject *list)
    {
        bool allString = true;
        Shiboken::AutoDecRef fast(PySequence_Fast(list, "Failed to convert QVariantList"));
        Py_ssize_t size = PySequence_Fast_GET_SIZE(fast.object());
        for(int i = 0; i &lt; size; ++i) {
            PyObject* item = PySequence_Fast_GET_ITEM(fast.object(), i);
            if (!%CHECKTYPE[QString](item)) {
                allString = false;
                break;
            }
        }
        return allString;
    }
    static QVariant QVariant_convertToVariantMap(PyObject* map)
    {
        Py_ssize_t pos = 0;
        Shiboken::AutoDecRef keys(PyDict_Keys(map));
        if (!QVariant_isStringList(keys))
            return QVariant();
        PyObject* key;
        PyObject* value;
        QMap&lt;QString,QVariant&gt; ret;
        while (PyDict_Next(map, &amp;pos, &amp;key, &amp;value)) {
            QString cppKey = %CONVERTTOCPP[QString](key);
            QVariant cppValue = %CONVERTTOCPP[QVariant](value);
            ret.insert(cppKey, cppValue);
        }
        return QVariant(ret);
    }
    static QVariant QVariant_convertToVariantList(PyObject* list)
    {
        if (QVariant_isStringList(list)) {
            QList&lt;QString &gt; lst = %CONVERTTOCPP[QList&lt;QString&gt;](list);
            return QVariant(QStringList(lst));
        }
        QVariant valueList = QVariant_convertToValueList(list);
        if (valueList.isValid())
            return valueList;
        QList&lt;QVariant&gt; lst;
        Shiboken::AutoDecRef fast(PySequence_Fast(list, "Failed to convert QVariantList"));
        Py_ssize_t size = PySequence_Fast_GET_SIZE(fast.object());
        for (int i = 0; i &lt; size; ++i) {
            PyObject* pyItem = PySequence_Fast_GET_ITEM(fast.object(), i);
            QVariant item = %CONVERTTOCPP[QVariant](pyItem);
            lst.append(item);
        }
        return QVariant(lst);
    }
    </inject-code>

  <primitive-type name="QVariant::Type" default-constructor="QVariant::Invalid">
    <conversion-rule>
        <native-to-target>
        const char* typeName = QVariant::typeToName(%in);
        PyObject* %out;
        PyTypeObject* pyType = 0;
        if (typeName)
            pyType = Shiboken::Conversions::getPythonTypeObject(typeName);
        %out = pyType ? ((PyObject*)pyType) : Py_None;
        Py_INCREF(%out);
        return %out;
        </native-to-target>
        <target-to-native>
            <add-conversion type="Py_None">
            %out = QVariant::Invalid;
            </add-conversion>
            <add-conversion type="PyTypeObject">
            const char* typeName;
            if (Shiboken::String::checkType((PyTypeObject*)%in))
                typeName = "QString";
            else if (%in == (PyObject*)&amp;PyFloat_Type)
                typeName = "double"; // float is a UserType in QVariant.
            else if (%in == (PyObject*)&amp;PyLong_Type)
                typeName = "int";    // long is a UserType in QVariant.
            else if (%in->ob_type == &amp;SbkObjectType_Type)
                typeName = Shiboken::ObjectType::getOriginalName((SbkObjectType*)%in);
            else
                typeName = ((PyTypeObject*)%in)->tp_name;
            %out = QVariant::nameToType(typeName);
            </add-conversion>
            <add-conversion type="PyString" check="Shiboken::String::check(%in)">
            %out = QVariant::nameToType(Shiboken::String::toCString(%in));
            </add-conversion>
            <add-conversion type="PyDict" check="PyDict_Check(%in) &amp;&amp; QVariantType_checkAllStringKeys(%in)">
            %out = QVariant::nameToType("QVariantMap");
            </add-conversion>
            <add-conversion type="PySequence">
            const char* typeName;
            if (QVariantType_isStringList(%in))
                typeName = "QStringList";
            else
                typeName = "QVariantList";
            %out = QVariant::nameToType(typeName);
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </primitive-type>

  <primitive-type name="QVariantMap" target-lang-api-name="PyDict"/>
  <inject-code class="target" position="end">
  Shiboken::Conversions::registerConverterName(SbkPySide_QtCoreTypeConverters[SBK_QTCORE_QMAP_QSTRING_QVARIANT_IDX], "QVariantMap");
  </inject-code>

  <inject-code class="native" position="beginning">
  static bool QVariantType_isStringList(PyObject* list)
  {
      bool allString = true;
      Shiboken::AutoDecRef fast(PySequence_Fast(list, "Failed to convert QVariantList"));
      Py_ssize_t size = PySequence_Fast_GET_SIZE(fast.object());
      for(int i=0; i &lt; size; i++) {
          PyObject* item = PySequence_Fast_GET_ITEM(fast.object(), i);
          if (!%CHECKTYPE[QString](item)) {
              allString = false;
              break;
          }
      }
      return allString;
  }
  static bool QVariantType_checkAllStringKeys(PyObject* dict)
  {
      Shiboken::AutoDecRef keys(PyDict_Keys(dict));
      return QVariantType_isStringList(keys);
  }
  </inject-code>

  <primitive-type name="QStringList">
    <include file-name="QStringList" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cpplist_to_pylist_conversion">
                <replace from="%INTYPE_0" to="QString" />
            </insert-template>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PySequence">
                <insert-template name="pyseq_to_cpplist_conversion">
                    <replace from="%OUTTYPE_0" to="QString" />
                </insert-template>
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </primitive-type>

  <primitive-type name="QModelIndexList">
    <include file-name="qabstractitemmodel.h" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cpplist_to_pylist_conversion">
                <replace from="%INTYPE_0" to="QModelIndex" />
            </insert-template>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PySequence">
                <insert-template name="pyseq_to_cpplist_conversion">
                    <replace from="%OUTTYPE_0" to="QModelIndex" />
                </insert-template>
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </primitive-type>

  <container-type name="QSet" type="set">
    <include file-name="QSet" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cpplist_to_pylist_conversion"/>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PySequence">
                <insert-template name="pyseq_to_cpplist_conversion"/>
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </container-type>

  <container-type name="QList" type="list">
    <include file-name="QList" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cpplist_to_pylist_conversion"/>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PySequence">
                <insert-template name="pyseq_to_cpplist_conversion"/>
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </container-type>

  <container-type name="QVector" type="vector">
    <include file-name="QVector" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cppvector_to_pylist_conversion"/>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PySequence">
                <insert-template name="pyseq_to_cppvector_conversion"/>
            </add-conversion>
        </target-to-native>
    </conversion-rule>

  </container-type>

  <container-type name="QStack" type="stack">
    <include file-name="QStack" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cpplist_to_pylist_conversion"/>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PySequence">
                <insert-template name="pyseq_to_cpplist_conversion"/>
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </container-type>

  <container-type name="QQueue" type="queue">
    <include file-name="QQueue" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cpplist_to_pylist_conversion"/>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PySequence">
                <insert-template name="pyseq_to_cpplist_conversion"/>
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </container-type>

  <container-type name="QLinkedList" type="linked-list">
    <include file-name="QLinkedList" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cpplist_to_pylist_conversion"/>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PySequence">
                <insert-template name="pyseq_to_cpplist_conversion"/>
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </container-type>

  <template name="cppmap_to_pymap_conversion">
    PyObject* %out = PyDict_New();
    %INTYPE::const_iterator it = %in.begin();
    for (; it != %in.end(); ++it) {
        %INTYPE_0 key = it.key();
        %INTYPE_1 value = it.value();
        PyDict_SetItem(%out,
                       %CONVERTTOPYTHON[%INTYPE_0](key),
                       %CONVERTTOPYTHON[%INTYPE_1](value));
    }
    return %out;
  </template>
  <template name="pydict_to_cppmap_conversion">
    PyObject* key;
    PyObject* value;
    Py_ssize_t pos = 0;
    while (PyDict_Next(%in, &amp;pos, &amp;key, &amp;value)) {
        %OUTTYPE_0 cppKey = %CONVERTTOCPP[%OUTTYPE_0](key);
        %OUTTYPE_1 cppValue = %CONVERTTOCPP[%OUTTYPE_1](value);
        %out.insert(cppKey, cppValue);
    }
  </template>

  <container-type name="QHash" type="hash">
    <include file-name="QHash" location="global"/>
    <include file-name="pysideconversions.h" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cppmap_to_pymap_conversion"/>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PyDict">
                <insert-template name="pydict_to_cppmap_conversion"/>
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </container-type>
  <container-type name="QMap" type="map">
    <include file-name="QMap" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cppmap_to_pymap_conversion"/>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PyDict">
                <insert-template name="pydict_to_cppmap_conversion"/>
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </container-type>
  <container-type name="QMultiMap" type="multi-map">
    <include file-name="QMultiMap" location="global"/>
    <conversion-rule>
        <native-to-target>
            <insert-template name="cppmap_to_pymap_conversion"/>
        </native-to-target>
        <target-to-native>
            <add-conversion type="PyDict">
                <insert-template name="pydict_to_cppmap_conversion"/>
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </container-type>

  <container-type name="QPair" type="pair">
    <include file-name="QPair" location="global"/>
    <conversion-rule>
        <native-to-target>
        PyObject* %out = PyTuple_New(2);
        PyTuple_SET_ITEM(%out, 0, %CONVERTTOPYTHON[%INTYPE_0](%in.first));
        PyTuple_SET_ITEM(%out, 1, %CONVERTTOPYTHON[%INTYPE_1](%in.second));
        return %out;
        </native-to-target>
        <target-to-native>
            <add-conversion type="PySequence">
            %out.first = %CONVERTTOCPP[%OUTTYPE_0](PySequence_Fast_GET_ITEM(%in, 0));
            %out.second = %CONVERTTOCPP[%OUTTYPE_1](PySequence_Fast_GET_ITEM(%in, 1));
            </add-conversion>
        </target-to-native>
    </conversion-rule>
  </container-type>

  <rejection class="*" function-name="d_func"/>
  <rejection class="*" function-name="data_ptr"/>
  <rejection class="*" function-name="detach"/>
  <rejection class="*" function-name="isDetached"/>
  <rejection class="*" field-name="d_ptr"/>
  <rejection class="*" field-name="d"/>
  <rejection class="*" field-name="staticMetaObject"/>
  <!-- not support array in property -->
  <rejection class="QTextCodec::ConverterState" field-name="state_data"/>
  <rejection class="QUuid" field-name="data1"/>
  <rejection class="QUuid" field-name="data2"/>
  <rejection class="QUuid" field-name="data3"/>
  <rejection class="QUuid" field-name="data4"/>
  <rejection class="" enum-name="QtValidLicenseForTestModule"/>
  <rejection class="" enum-name="QtValidLicenseForDBusModule"/>
  <rejection class="" enum-name="QtValidLicenseForSqlModule"/>
  <rejection class="" enum-name="QtValidLicenseForOpenGLModule"/>
  <rejection class="" enum-name="QtValidLicenseForScriptToolsModule"/>
  <rejection class="" enum-name="__codecvt_result"/>
  <rejection class="" enum-name="enum_1"/>
  <rejection class="" enum-name="enum_2"/>
  <rejection class="" enum-name="QtValidLicenseForXmlModule"/>
  <rejection class="" enum-name="QtValidLicenseForXmlPatternsModule"/>
  <rejection class="" enum-name="QtValidLicenseForActiveQtModule"/>
  <rejection class="" enum-name="QtValidLicenseForCoreModule"/>
  <rejection class="" enum-name="QtValidLicenseForQt3SupportLightModule"/>
  <rejection class="" enum-name="QtValidLicenseForQt3SupportModule"/>
  <rejection class="" enum-name="QtValidLicenseForNetworkModule"/>
  <rejection class="" enum-name="QtValidLicenseForSvgModule"/>
  <rejection class="" enum-name="QtValidLicenseForGuiModule"/>
  <rejection class="" enum-name="QtValidLicenseForScriptModule"/>
  <rejection class="" enum-name="QtValidLicenseForHelpModule"/>
  <rejection class="QtConcurrent" enum-name="enum_1"/>
  <rejection class="QAbstractEventDispatcher" function-name="filterEvent"/>
  <rejection class="QAbstractEventDispatcher" function-name="setEventFilter"/>
  <!-- Internal -->
  <rejection class="QAbstractFileEngine" function-name="endEntryList"/>
  <rejection class="QAbstractFileEngine" function-name="extension"/>
  <rejection class="QCoreApplication" function-name="compressEvent"/>
  <rejection class="QCoreApplication" function-name="eventFilter"/>
  <rejection class="QCoreApplication" function-name="filterEvent"/>
  <rejection class="QCoreApplication" function-name="setEventFilter"/>
  <rejection class="QFile" function-name="setDecodingFunction"/>
  <rejection class="QFile" function-name="setEncodingFunction"/>
  <rejection class="QRegion" function-name="cleanUp"/>
  <rejection class="QSettings" function-name="registerFormat"/>
  <rejection class="QAbstractFileEngineIterator" function-name="entryInfo"/>
  <rejection class="QAbstractFileEngineIterator" enum-name="EntryInfoType"/>
  <namespace-type name="Qt">
    <enum-type name="AlignmentFlag" flags="Alignment" />
    <enum-type name="AnchorAttribute"/>
    <enum-type name="AnchorPoint" since="4.6" />
    <enum-type name="ApplicationAttribute"/>
    <enum-type name="ArrowType"/>
    <enum-type name="AspectRatioMode"/>
    <enum-type name="Axis"/>
    <enum-type name="BGMode"/>
    <enum-type name="BrushStyle"/>
    <enum-type name="CaseSensitivity"/>
    <enum-type name="CheckState"/>
    <enum-type name="ClipOperation"/>
    <enum-type name="ConnectionType"/>
    <enum-type name="ContextMenuPolicy"/>
    <enum-type name="CoordinateSystem" since="4.6"/>
    <enum-type name="Corner"/>
    <enum-type name="CursorShape" />
    <enum-type name="DateFormat" />
    <enum-type name="DayOfWeek"/>
    <enum-type name="DockWidgetArea" flags="DockWidgetAreas" />
    <enum-type name="DockWidgetAreaSizes"/>
    <enum-type name="DropAction" flags="DropActions"/>
    <enum-type name="EventPriority"/>
    <enum-type name="FillRule"/>
    <enum-type name="FocusPolicy"/>
    <enum-type name="FocusReason"/>
    <enum-type name="GestureFlag" flags="GestureFlags" since="4.6"/>
    <enum-type name="GestureState" since="4.6"/>
    <enum-type name="GestureType" since="4.6"/>
    <enum-type name="GlobalColor"/>
    <enum-type name="HitTestAccuracy"/>
    <enum-type name="ImageConversionFlag" flags="ImageConversionFlags" />
    <enum-type name="InputMethodHint" flags="InputMethodHints" since="4.6"/>
    <enum-type name="InputMethodQuery"/>
    <enum-type name="ItemDataRole" force-integer="yes" />
    <enum-type name="ItemFlag" flags="ItemFlags"/>
    <enum-type name="ItemSelectionMode"/>
    <enum-type name="Key" />
    <enum-type name="KeyboardModifier" flags="KeyboardModifiers"/>
    <enum-type name="LayoutDirection"/>
    <enum-type name="MaskMode"/>
    <enum-type name="MatchFlag" flags="MatchFlags"/>
    <enum-type name="Modifier"/>
    <enum-type name="MouseButton" flags="MouseButtons"/>
    <enum-type name="NavigationMode" since="4.6"/>
    <enum-type name="Orientation" flags="Orientations"/>
    <enum-type name="PenCapStyle"/>
    <enum-type name="PenJoinStyle"/>
    <enum-type name="PenStyle"/>
    <enum-type name="ScrollBarPolicy"/>
    <enum-type name="ShortcutContext"/>
    <enum-type name="SizeHint"/>
    <enum-type name="SizeMode"/>
    <enum-type name="SortOrder"/>
    <enum-type name="TextElideMode"/>
    <enum-type name="TextFlag"/>
    <enum-type name="TextFormat"/>
    <enum-type name="TextInteractionFlag" flags="TextInteractionFlags"/>
    <enum-type name="TileRule" since="4.6"/>
    <enum-type name="TimeSpec"/>
    <enum-type name="ToolBarArea" flags="ToolBarAreas" />
    <enum-type name="ToolBarAreaSizes"/>
    <enum-type name="ToolButtonStyle"/>
    <enum-type name="TouchPointState" since="4.6"/>
    <enum-type name="TransformationMode"/>
    <enum-type name="UIEffect"/>
    <enum-type name="WhiteSpaceMode" />
    <enum-type name="WidgetAttribute" />
    <enum-type name="WindowFrameSection"/>
    <enum-type name="WindowModality"/>
    <enum-type name="WindowState" flags="WindowStates"/>
    <enum-type name="WindowType" flags="WindowFlags"/>
    <enum-type name="CursorMoveStyle" since="4.8" revision="4800"/>

   <!--### These functions are part of QtGui, not QtCore -->
    <modify-function signature="codecForHtml(const QByteArray &amp;)" remove="all"/>
    <modify-function signature="mightBeRichText(const QString &amp;)" remove="all"/>
    <modify-function signature="escape(const QString&amp;)" remove="all"/>
    <modify-function signature="convertFromPlainText(const QString &amp;, Qt::WhiteSpaceMode)" remove="all"/>
    <!--### -->
    <extra-includes>
      <include file-name="QTextDocument" location="global"/>
    </extra-includes>
  </namespace-type>

  <add-function signature="qAbs(double)" return-type="double">
    <inject-code class="target" position="beginning">
    double _abs = qAbs(%1);
    %PYARG_0 = %CONVERTTOPYTHON[double](_abs);
    </inject-code>
  </add-function>

  <inject-code class="native" position="beginning">
    namespace PySide {
    static QStack&lt;PyObject*&gt; globalPostRoutineFunctions;
    void globalPostRoutineCallback()
    {
        foreach(PyObject* callback, globalPostRoutineFunctions) {
            Shiboken::AutoDecRef result(PyObject_CallObject(callback, NULL));
            Py_DECREF(callback);
        }
        globalPostRoutineFunctions.clear();
    }
    void addPostRoutine(PyObject* callback)
    {
        if (PyCallable_Check(callback)) {
            globalPostRoutineFunctions &lt;&lt; callback;
            Py_INCREF(callback);
        } else {
            PyErr_SetString(PyExc_TypeError, "qAddPostRoutine: The argument must be a callable object.");
        }
    }
    } // namespace
  </inject-code>
  <add-function signature="qAddPostRoutine(PyObject*)">
    <inject-code class="target" position="beginning">
        PySide::addPostRoutine(%1);
    </inject-code>
  </add-function>
  <inject-code class="target" position="end">
    qAddPostRoutine(PySide::globalPostRoutineCallback);
  </inject-code>

  <inject-code class="target" position="end">
  QList&lt;QByteArray&gt; version = QByteArray(qVersion()).split('.');
  PyObject* pyQtVersion = PyTuple_New(3);
  for (int i = 0; i &lt; 3; ++i)
      PyTuple_SET_ITEM(pyQtVersion, i, PyInt_FromLong(version[i].toInt()));
  PyModule_AddObject(module, "__version_info__", pyQtVersion);
  PyModule_AddStringConstant(module, "__version__", qVersion());
  </inject-code>

  <inject-code class="target" position="end">
    { // Avoid name clash
        Shiboken::AutoDecRef atexit(Shiboken::Module::import("atexit"));
        Shiboken::AutoDecRef regFunc(PyObject_GetAttrString(atexit, "register"));
        PyObject* shutDownFunc = PyObject_GetAttrString(module, "__moduleShutdown");
        Shiboken::AutoDecRef args(PyTuple_New(1));
        PyTuple_SET_ITEM(args, 0, shutDownFunc);
        Shiboken::AutoDecRef retval(PyObject_Call(regFunc, args, 0));
        Q_ASSERT(!retval.isNull());
    }
  </inject-code>

  <add-function signature="__moduleShutdown()">
      <inject-code class="target" position="beginning">
        PySide::runCleanupFunctions();
    </inject-code>
  </add-function>

  <!--signal/slot-->
  <inject-code class="target" position="end">
    Shiboken::Conversions::registerConverterName(SbkPySide_QtCoreTypeConverters[SBK_QSTRING_IDX], "unicode");
    Shiboken::Conversions::registerConverterName(SbkPySide_QtCoreTypeConverters[SBK_QSTRING_IDX], "str");
    Shiboken::Conversions::registerConverterName(SbkPySide_QtCoreTypeConverters[SBK_QTCORE_QLIST_QVARIANT_IDX], "QVariantList");

    PySide::init(module);
    Py_AtExit(QtCoreModuleExit);
  </inject-code>
  <inject-code class="native" position="beginning">
    #include &lt;pyside.h&gt;
  </inject-code>

  <inject-code class="native" position="beginning">
    // Define a global variable to handle qInstallMsgHandler callback
    static PyObject* qtmsghandler = 0;

    static void msgHandlerCallback(QtMsgType type, const char* msg)
    {
        Shiboken::GilState state;
        Shiboken::AutoDecRef arglist(PyTuple_New(2));
        PyTuple_SET_ITEM(arglist, 0, %CONVERTTOPYTHON[QtMsgType](type));
        PyTuple_SET_ITEM(arglist, 1, %CONVERTTOPYTHON[const char*](msg));
        Shiboken::AutoDecRef ret(PyObject_CallObject(qtmsghandler, arglist));
    }
    static void QtCoreModuleExit()
    {
        PySide::SignalManager::instance().clear();
    }
  </inject-code>
  <add-function signature="qInstallMsgHandler(PyObject)" return-type="PyObject">
    <inject-code class="target" position="beginning">
      if (%PYARG_1 == Py_None) {
        qInstallMsgHandler(0);
        %PYARG_0 = qtmsghandler ? qtmsghandler : Py_None;
        qtmsghandler = 0;
      } else if (!PyCallable_Check(%PYARG_1)) {
        PyErr_SetString(PyExc_TypeError, "parameter must be callable");
      } else {
        %PYARG_0 = qtmsghandler ? qtmsghandler : Py_None;
        Py_INCREF(%PYARG_1);
        qtmsghandler = %PYARG_1;
        qInstallMsgHandler(msgHandlerCallback);
      }

      if (%PYARG_0 == Py_None)
        Py_INCREF(%PYARG_0);

    </inject-code>
  </add-function>

  <value-type name="QElapsedTimer" since="4.7">
    <enum-type name="ClockType" since="4.7"/>
  </value-type>

  <object-type name="QAbstractTableModel" polymorphic-id-expression="qobject_cast&lt;QAbstractTableModel*&gt;(%1)">
    <extra-includes>
      <include file-name="QStringList" location="global"/>
      <include file-name="QSize" location="global"/>
    </extra-includes>
  </object-type>
  <value-type name="QLine" hash-function="PySide::hash">
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%i, %i, %i, %i" />
               <replace from="%REPR_ARGS" to="%CPPSELF.x1(), %CPPSELF.y1(), %CPPSELF.x2(), %CPPSELF.y2()" />
             </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="iiii" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.x1(), %CPPSELF.y1(), %CPPSELF.x2(), %CPPSELF.y2()" />
            </insert-template>
        </inject-code>
    </add-function>
    <inject-code class="native" position="beginning">
      namespace PySide {
          template&lt;&gt; inline uint hash(const QLine&amp; v) {
              return qHash(qMakePair(qMakePair(v.x1(), v.y1()), qMakePair(v.x2(), v.y2())));
          }
      };
    </inject-code>

    <add-function signature="toTuple" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="to_tuple">
                <replace from="%TT_FORMAT" to="iiii" />
                <replace from="%TT_ARGS" to="%CPPSELF.x1(), %CPPSELF.y1(), %CPPSELF.x2(), %CPPSELF.y2()" />
            </insert-template>
        </inject-code>
    </add-function>
  </value-type>
  <value-type name="QLineF">
    <enum-type name="IntersectType" />
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%f, %f, %f, %f" />
               <replace from="%REPR_ARGS" to="%CPPSELF.x1(), %CPPSELF.y1(), %CPPSELF.x2(), %CPPSELF.y2()" />
             </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="dddd" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.x1(), %CPPSELF.y1(), %CPPSELF.x2(), %CPPSELF.y2()" />
            </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="toTuple" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="to_tuple">
                <replace from="%TT_FORMAT" to="dddd" />
                <replace from="%TT_ARGS" to="%CPPSELF.x1(), %CPPSELF.y1(), %CPPSELF.x2(), %CPPSELF.y2()" />
            </insert-template>
        </inject-code>
    </add-function>
    <modify-function signature="intersect(QLineF, QPointF*)const">
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(intersectType, intersectionPoint)" />
        </modify-argument>
        <inject-code class="target" position="beginning">
        QPointF p;
        %RETURN_TYPE retval = %CPPSELF.%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;p);
        %PYARG_0 = PyTuple_New(2);
        PyTuple_SET_ITEM(%PYARG_0, 0, %CONVERTTOPYTHON[%RETURN_TYPE](retval));
        PyTuple_SET_ITEM(%PYARG_0, 1, %CONVERTTOPYTHON[QPointF](p));
        </inject-code>
    </modify-function>
  </value-type>
  <object-type name="QResource">
    <modify-function signature="data()const">
        <inject-documentation format="target">
            Returns a read only buffer object pointing to the segment of data that this resource represents. If the resource is compressed the data returns is compressed and qUncompress() must be used to access the data. If the resource is a directory None is returned.
        </inject-documentation>
        <modify-argument index="return">
            <replace-type modified-type="PyObject" />
        </modify-argument>
        <inject-code>
            const void* d = %CPPSELF.%FUNCTION_NAME();
            if (d) {
                %PYARG_0 = Shiboken::Buffer::newObject(d, %CPPSELF.size());
            } else {
                Py_INCREF(Py_None);
                %PYARG_0 = Py_None;
            }
        </inject-code>
    </modify-function>
    <template name="QResource_registerResource">
    uchar* ptr = (uchar*) Shiboken::Buffer::getPointer(%PYARG_1);
    %RETURN_TYPE %0 = %CPPSELF.%FUNCTION_NAME(const_cast&lt;const uchar*>(ptr), %2);
    %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
    </template>

    <modify-function signature="unregisterResource(const uchar*, const QString&amp;)" rename="unregisterResourceData">
      <modify-argument index="1">
        <replace-type modified-type="PyBuffer"/>
      </modify-argument>
      <inject-code>
        <insert-template name="QResource_registerResource" />
      </inject-code>
    </modify-function>
    <modify-function signature="registerResource(const uchar*, const QString&amp;)" rename="registerResourceData">
      <modify-argument index="1">
        <replace-type modified-type="PyBuffer"/>
      </modify-argument>
      <inject-code>
        <insert-template name="QResource_registerResource" />
      </inject-code>
    </modify-function>
  </object-type>

  <value-type name="QBasicTimer"/>
  <value-type name="QByteArrayMatcher"/>
  <value-type name="QDate" hash-function="PySide::hash" >
    <template name="pydatetime_importandcheck_function">
    #ifdef IS_PY3K
    #define PySideDateTime_IMPORT PyDateTime_IMPORT
    #else
    #define PySideDateTime_IMPORT \
                (PyDateTimeAPI = (PyDateTime_CAPI*) PyCObject_Import((char*)"datetime", \
                                                                 (char*)"datetime_CAPI"))
    #endif
    static bool PyDateTime_ImportAndCheck(PyObject* pyIn) {
        if (!PyDateTimeAPI) PySideDateTime_IMPORT;
        return $DATETIMETYPE_Check(pyIn);
    }
    </template>
    <inject-code class="native" position="beginning">
        <insert-template name="pydatetime_importandcheck_function">
            <replace from="$DATETIMETYPE" to="PyDate" />
        </insert-template>
    </inject-code>
    <conversion-rule>
        <target-to-native>
            <add-conversion type="Py_None">
            %out = %OUTTYPE();
            </add-conversion>
            <add-conversion type="PyDate" check="PyDateTime_ImportAndCheck(%in)">
            int day = PyDateTime_GET_DAY(%in);
            int month = PyDateTime_GET_MONTH(%in);
            int year = PyDateTime_GET_YEAR(%in);
            %out = %OUTTYPE(year, month, day);
            </add-conversion>
        </target-to-native>
    </conversion-rule>
    <extra-includes>
      <include file-name="datetime.h" location="global"/>
    </extra-includes>
    <enum-type name="MonthNameType"/>
    <add-function signature="__repr__" return-type="PyObject">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%i, %i, %i" />
               <replace from="%REPR_ARGS" to="%CPPSELF.year(), %CPPSELF.month(), %CPPSELF.day()" />
             </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="__reduce__" return-type="PyObject">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="iii" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.year(), %CPPSELF.month(), %CPPSELF.day()" />
            </insert-template>
        </inject-code>
    </add-function>
    <add-function signature="toPython()" return-type="PyObject">
        <inject-code class="target" position="beginning">
        if (!PyDateTimeAPI) PySideDateTime_IMPORT;
        %PYARG_0 = PyDate_FromDate(%CPPSELF.year(), %CPPSELF.month(), %CPPSELF.day());
        </inject-code>
    </add-function>
    <modify-function signature="getDate(int*,int*,int*)" >
        <modify-argument index="1">
            <remove-argument/>
        </modify-argument>
        <modify-argument index="2">
            <remove-argument/>
        </modify-argument>
        <modify-argument index="3">
            <remove-argument/>
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(year, month, day)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
        int year, month, day;
        %BEGIN_ALLOW_THREADS
        %CPPSELF.%FUNCTION_NAME(&amp;year, &amp;month, &amp;day);
        %END_ALLOW_THREADS
        %PYARG_0 = PyTuple_New(3);
        PyTuple_SET_ITEM(%PYARG_0, 0, %CONVERTTOPYTHON[int](year));
        PyTuple_SET_ITEM(%PYARG_0, 1, %CONVERTTOPYTHON[int](month));
        PyTuple_SET_ITEM(%PYARG_0, 2, %CONVERTTOPYTHON[int](day));
        </inject-code>
    </modify-function>
    <modify-function signature="weekNumber(int*)const" >
        <modify-argument index="1">
            <remove-argument/>
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(week, yearNumber)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
        int yearNumber;
        %BEGIN_ALLOW_THREADS
        int week = %CPPSELF.%FUNCTION_NAME(&amp;yearNumber);
        %END_ALLOW_THREADS
        %PYARG_0 = PyTuple_New(2);
        PyTuple_SET_ITEM(%PYARG_0, 0, %CONVERTTOPYTHON[int](week));
        PyTuple_SET_ITEM(%PYARG_0, 1, %CONVERTTOPYTHON[int](yearNumber));
        </inject-code>
    </modify-function>
    <!-- This function isn't part of Qt public API -->
    <modify-function signature="julianToGregorian(uint,int&amp;,int&amp;,int&amp;)" remove="all"/>
  </value-type>
  <value-type name="QDateTime" hash-function="PySide::hash">
    <inject-code class="native" position="beginning">
        <insert-template name="pydatetime_importandcheck_function">
            <replace from="$DATETIMETYPE" to="PyDateTime" />
        </insert-template>
    </inject-code>
    <conversion-rule>
        <target-to-native>
            <add-conversion type="Py_None">
            %out = %OUTTYPE();
            </add-conversion>
            <add-conversion type="PyDateTime" check="PyDateTime_ImportAndCheck(%in)">
            int day = PyDateTime_GET_DAY(%in);
            int month = PyDateTime_GET_MONTH(%in);
            int year = PyDateTime_GET_YEAR(%in);
            int hour = PyDateTime_DATE_GET_HOUR(%in);
            int min = PyDateTime_DATE_GET_MINUTE(%in);
            int sec = PyDateTime_DATE_GET_SECOND(%in);
            int usec = PyDateTime_DATE_GET_MICROSECOND(%in);
            %out = %OUTTYPE(QDate(year, month, day), QTime(hour, min, sec, usec/1000));
            </add-conversion>
        </target-to-native>
    </conversion-rule>
    <extra-includes>
      <include file-name="datetime.h" location="global"/>
    </extra-includes>
    <!-- Somewhat internal constructor used to pickle QDateTime -->
    <add-function signature="QDateTime(int, int, int, int, int, int, int, int)">
        <modify-argument index="8">
          <replace-default-expression with="Qt::LocalTime"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            QDate date(%1, %2, %3);
            QTime time(%4, %5, %6, %7);
            %0 = new %TYPE(date, time, Qt::TimeSpec(%8));
        </inject-code>
    </add-function>
    <add-function signature="QDateTime(int, int, int, int, int, int)">
        <inject-code class="target" position="beginning">
            QDate date(%1, %2, %3);
            QTime time(%4, %5, %6);
            %0 = new %TYPE(date, time);
        </inject-code>
    </add-function>
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%i, %i, %i, %i, %i, %i, %i, %i" />
               <replace from="%REPR_ARGS" to="%CPPSELF.date().year(), %CPPSELF.date().month(), %CPPSELF.date().day(), %CPPSELF.time().hour(), %CPPSELF.time().minute(), %CPPSELF.time().second(), %CPPSELF.time().msec(), (int)%CPPSELF.timeSpec()" />
             </insert-template>
        </inject-code>
    </add-function>
    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="iiiiiiii" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.date().year(), %CPPSELF.date().month(), %CPPSELF.date().day(), %CPPSELF.time().hour(), %CPPSELF.time().minute(), %CPPSELF.time().second(), %CPPSELF.time().msec(), (int)%CPPSELF.timeSpec()" />
            </insert-template>
        </inject-code>
    </add-function>
    <add-function signature="toPython()" return-type="PyObject">
        <inject-code class="target" position="beginning">
        QDate date = %CPPSELF.date();
        QTime time = %CPPSELF.time();
        if (!PyDateTimeAPI) PySideDateTime_IMPORT;
        %PYARG_0 = PyDateTime_FromDateAndTime(date.year(), date.month(), date.day(), time.hour(), time.minute(), time.second(), time.msec()*1000);
        </inject-code>
    </add-function>
  </value-type>
  <value-type name="QDir">
    <enum-type name="Filter" flags="Filters"/>
    <enum-type name="SortFlag" flags="SortFlags" />
    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="s" />
              <replace from="%REDUCE_ARGS" to="qPrintable(%CPPSELF.path())" />
            </insert-template>
        </inject-code>
    </add-function>
  </value-type>

  <value-type name="QPoint" hash-function="PySide::hash">
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%i, %i" />
               <replace from="%REPR_ARGS" to="%CPPSELF.x(), %CPPSELF.y()" />
             </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="ii" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.x(), %CPPSELF.y()" />
            </insert-template>
        </inject-code>
    </add-function>
    <inject-code class="native" position="beginning">
      namespace PySide {
          template&lt;&gt; inline uint hash(const QPoint&amp; v) {
              return qHash(qMakePair(v.x(), v.y()));
          }
      };
    </inject-code>

    <add-function signature="toTuple" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="to_tuple">
                <replace from="%TT_FORMAT" to="ii" />
                <replace from="%TT_ARGS" to="%CPPSELF.x(), %CPPSELF.y()" />
            </insert-template>
        </inject-code>
    </add-function>

    <!--### Functions removed because they return references to Python imutable objects -->
    <modify-function signature="rx()" remove="all"/>
    <modify-function signature="ry()" remove="all"/>
    <!--### -->
  </value-type>
  <value-type name="QPointF">
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%f, %f" />
               <replace from="%REPR_ARGS" to="%CPPSELF.x(), %CPPSELF.y()" />
             </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="dd" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.x(), %CPPSELF.y()" />
            </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="toTuple" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="to_tuple">
                <replace from="%TT_FORMAT" to="dd" />
                <replace from="%TT_ARGS" to="%CPPSELF.x(), %CPPSELF.y()" />
            </insert-template>
        </inject-code>
    </add-function>

    <!--### Functions removed because they return references to Python imutable objects -->
    <modify-function signature="rx()" remove="all"/>
    <modify-function signature="ry()" remove="all"/>
    <!--### -->
  </value-type>
  <value-type name="QRect" hash-function="PySide::hash">
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%i, %i, %i, %i" />
               <replace from="%REPR_ARGS" to="%CPPSELF.x(), %CPPSELF.y(), %CPPSELF.width(), %CPPSELF.height()" />
             </insert-template>
        </inject-code>
    </add-function>
    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="iiii" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.x(), %CPPSELF.y(), %CPPSELF.width(), %CPPSELF.height()" />
            </insert-template>
        </inject-code>
    </add-function>
    <inject-code class="native" position="beginning">
      namespace PySide {
          template&lt;&gt; inline uint hash(const QRect&amp; v) {
              return qHash(qMakePair(qMakePair(v.x(), v.y()), qMakePair(v.width(), v.height())));
          }
      };
    </inject-code>

    <modify-function signature="getCoords(int*,int*,int*,int*)const">
        <modify-argument index="return">
            <replace-type modified-type="PyObject" />
        </modify-argument>
        <modify-argument index="1">
            <remove-argument />
        </modify-argument>
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <modify-argument index="3">
            <remove-argument />
        </modify-argument>
        <modify-argument index="4">
            <remove-argument />
        </modify-argument>
        <inject-code class="target">
            <insert-template name="fix_number*,number*,number*,number*">
                <replace from="$TYPE" to="int" />
            </insert-template>
        </inject-code>
    </modify-function>
    <modify-function signature="getRect(int*,int*,int*,int*)const">
        <modify-argument index="return">
            <replace-type modified-type="PyObject" />
        </modify-argument>
        <modify-argument index="1">
            <remove-argument />
        </modify-argument>
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <modify-argument index="3">
            <remove-argument />
        </modify-argument>
        <modify-argument index="4">
            <remove-argument />
        </modify-argument>
        <inject-code class="target">
            <insert-template name="fix_number*,number*,number*,number*">
                <replace from="$TYPE" to="int" />
            </insert-template>
        </inject-code>
    </modify-function>
  </value-type>
  <value-type name="QRectF">
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%f, %f, %f, %f" />
               <replace from="%REPR_ARGS" to="%CPPSELF.x(), %CPPSELF.y(), %CPPSELF.width(), %CPPSELF.height()" />
             </insert-template>
        </inject-code>
    </add-function>

   <!--
         FIXME These functions return qreal. Will convert to double (format
         string) mess things up in other architectures?
    -->
    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="dddd" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.x(), %CPPSELF.y(), %CPPSELF.width(), %CPPSELF.height()" />
            </insert-template>
        </inject-code>
    </add-function>
    <modify-function signature="getCoords(qreal*,qreal*,qreal*,qreal*)const">
        <modify-argument index="return">
            <replace-type modified-type="PyObject" />
        </modify-argument>
        <modify-argument index="1">
            <remove-argument />
        </modify-argument>
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <modify-argument index="3">
            <remove-argument />
        </modify-argument>
        <modify-argument index="4">
            <remove-argument />
        </modify-argument>
        <inject-code class="target">
            <insert-template name="fix_number*,number*,number*,number*">
                <replace from="$TYPE" to="qreal" />
            </insert-template>
        </inject-code>
    </modify-function>
    <modify-function signature="getRect(qreal*,qreal*,qreal*,qreal*)const">
        <modify-argument index="return">
            <replace-type modified-type="PyObject" />
        </modify-argument>
        <modify-argument index="1">
            <remove-argument />
        </modify-argument>
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <modify-argument index="3">
            <remove-argument />
        </modify-argument>
        <modify-argument index="4">
            <remove-argument />
        </modify-argument>
        <inject-code class="target">
            <insert-template name="fix_number*,number*,number*,number*">
                <replace from="$TYPE" to="qreal" />
            </insert-template>
        </inject-code>
    </modify-function>
  </value-type>
  <value-type name="QSize" hash-function="PySide::hash">
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%i, %i" />
               <replace from="%REPR_ARGS" to="%CPPSELF.width(), %CPPSELF.height()" />
             </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="ii" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.width(), %CPPSELF.height()" />
            </insert-template>
        </inject-code>
    </add-function>
    <inject-code class="native" position="beginning">
      namespace PySide {
          template&lt;&gt; inline uint hash(const QSize&amp; v) {
              return qHash(qMakePair(v.width(), v.height()));
          }
      };
    </inject-code>

    <add-function signature="toTuple" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="to_tuple">
                <replace from="%TT_FORMAT" to="ii" />
                <replace from="%TT_ARGS" to="%CPPSELF.width(), %CPPSELF.height()" />
            </insert-template>
        </inject-code>
    </add-function>

    <!--### Functions removed because they return references to Python imutable objects -->
    <modify-function signature="rheight()" remove="all"/>
    <modify-function signature="rwidth()" remove="all"/>
    <!--### -->
  </value-type>
  <value-type name="QSizeF">
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%f, %f" />
               <replace from="%REPR_ARGS" to="%CPPSELF.width(), %CPPSELF.height()" />
             </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="dd" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.width(), %CPPSELF.height()" />
            </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="toTuple" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="to_tuple">
                <replace from="%TT_FORMAT" to="dd" />
                <replace from="%TT_ARGS" to="%CPPSELF.width(), %CPPSELF.height()" />
            </insert-template>
        </inject-code>
    </add-function>

    <!--### Functions removed because they return references to Python imutable objects -->
    <modify-function signature="rheight()" remove="all" />
    <modify-function signature="rwidth()" remove="all" />
    <!--### -->
  </value-type>

  <value-type name="QTime" hash-function="PySide::hash">
    <inject-code class="native" position="beginning">
        <insert-template name="pydatetime_importandcheck_function">
            <replace from="$DATETIMETYPE" to="PyTime" />
        </insert-template>
    </inject-code>
    <conversion-rule>
        <target-to-native>
            <add-conversion type="Py_None">
            %out = %OUTTYPE();
            </add-conversion>
            <add-conversion type="PyTime" check="PyDateTime_ImportAndCheck(%in)">
            int hour = PyDateTime_TIME_GET_HOUR(%in);
            int min = PyDateTime_TIME_GET_MINUTE(%in);
            int sec = PyDateTime_TIME_GET_SECOND(%in);
            int usec = PyDateTime_TIME_GET_MICROSECOND(%in);
            %out = %OUTTYPE(hour, min, sec, usec/1000);
            </add-conversion>
        </target-to-native>
    </conversion-rule>

    <extra-includes>
      <include file-name="datetime.h" location="global"/>
    </extra-includes>

    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="%i, %i, %i, %i" />
               <replace from="%REPR_ARGS" to="%CPPSELF.hour(), %CPPSELF.minute(), %CPPSELF.second(), %CPPSELF.msec()" />
             </insert-template>
        </inject-code>
    </add-function>
    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="iiii" />
              <replace from="%REDUCE_ARGS" to="%CPPSELF.hour(), %CPPSELF.minute(), %CPPSELF.second(), %CPPSELF.msec()" />
            </insert-template>
        </inject-code>
    </add-function>
    <add-function signature="toPython()" return-type="PyObject">
        <inject-code class="target" position="beginning">
        if (!PyDateTimeAPI) PySideDateTime_IMPORT;
        %PYARG_0 = PyTime_FromTime(%CPPSELF.hour(), %CPPSELF.minute(), %CPPSELF.second(), %CPPSELF.msec()*1000);
        </inject-code>
    </add-function>
  </value-type>
  <value-type name="QPersistentModelIndex" hash-function="qHash">
    <modify-function signature="internalPointer()const">
        <inject-code class="target" position="beginning">
            <insert-template name="return_internal_pointer" />
        </inject-code>
    </modify-function>
    <modify-function signature="operator const QModelIndex&amp;()const">
        <modify-argument index="return">
            <parent index="this" action="add"/>
        </modify-argument>
    </modify-function>
  </value-type>
  <value-type name="QUuid">
    <enum-type name="Variant"/>
    <enum-type name="Version"/>
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="'%s'" />
               <replace from="%REPR_ARGS" to="qPrintable(%CPPSELF.toString())" />
             </insert-template>
        </inject-code>
    </add-function>
    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="s" />
              <replace from="%REDUCE_ARGS" to="qPrintable(%CPPSELF.toString())" />
            </insert-template>
        </inject-code>
    </add-function>
  </value-type>

  <value-type name="QLocale">
    <enum-type name="Country" />
    <enum-type name="FormatType"/>
    <enum-type name="Language" />
    <enum-type name="MeasurementSystem"/>
    <enum-type name="NumberOption" flags="NumberOptions"/>
    <enum-type name="Script" since="4.8" revision="4800"/>
    <enum-type name="CurrencySymbolFormat" since="4.8" revision="4800"/>
    <enum-type name="QuotationStyle" since="4.8" revision="4800"/>
    <!--### All those C++ number types have the same representation in Python -->
    <modify-function signature="toString(qulonglong) const" remove="all"/>
    <modify-function signature="toString(ushort) const" remove="all"/>
    <modify-function signature="toString(unsigned int) const" remove="all"/>
    <!--### -->
    <extra-includes>
      <include file-name="QDate" location="global"/>
    </extra-includes>
    <modify-function signature="toTime(QString, QLocale::FormatType)const">
        <modify-argument index="2">
            <rename to="format" />
        </modify-argument>
    </modify-function>
    <modify-function signature="toDate(QString, QLocale::FormatType)const">
        <modify-argument index="2">
            <rename to="format" />
        </modify-argument>
    </modify-function>
    <modify-function signature="toUInt(QString,bool*,int)const">
        <modify-argument index="2">
            <remove-argument />
            <remove-default-expression />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(int, bool ok)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="fix_arg,bool*,arg" />
        </inject-code>
    </modify-function>
    <modify-function signature="toULongLong(QString,bool*,int)const">
        <modify-argument index="2">
            <remove-argument />
            <remove-default-expression />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(int, bool ok)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="fix_arg,bool*,arg" />
        </inject-code>
    </modify-function>
    <modify-function signature="toDouble(QString,bool*)const">
        <modify-argument index="2">
            <remove-argument />
            <remove-default-expression />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(float, bool ok)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="fix_args,bool*" />
        </inject-code>
    </modify-function>
    <modify-function signature="toFloat(QString,bool*)const">
        <modify-argument index="2">
            <remove-argument />
            <remove-default-expression />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(float, bool ok)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="fix_args,bool*" />
        </inject-code>
    </modify-function>
    <modify-function signature="toInt(QString,bool*,int)const">
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(int, bool ok)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="fix_arg,bool*,arg" />
        </inject-code>
    </modify-function>
    <modify-function signature="toLongLong(QString,bool*,int)const">
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(int, bool ok)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="fix_arg,bool*,arg" />
        </inject-code>
    </modify-function>
    <modify-function signature="toShort(QString,bool*,int)const">
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(int, bool ok)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="fix_arg,bool*,arg" />
        </inject-code>
    </modify-function>
    <modify-function signature="toUShort(QString,bool*,int)const">
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(int, bool ok)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="fix_arg,bool*,arg" />
        </inject-code>
    </modify-function>
  </value-type>
  <value-type name="QBitArray" hash-function="qHash" >
    <add-function signature="__len__">
        <inject-code class="target" position="beginning">
            return %CPPSELF.size();
        </inject-code>
    </add-function>
    <add-function signature="__getitem__">
        <inject-code class="target" position="beginning">
        if (_i &lt; 0 || _i >= %CPPSELF.size()) {
            PyErr_SetString(PyExc_IndexError, "index out of bounds");
            return 0;
        }
        bool ret = %CPPSELF.at(_i);
        return %CONVERTTOPYTHON[bool](ret);
        </inject-code>
    </add-function>
    <add-function signature="__setitem__">
        <inject-code class="target" position="beginning">
            PyObject* args = Py_BuildValue("(iiO)", _i, 1, _value);
            PyObject* result = Sbk_QBitArrayFunc_setBit(self, args);
            Py_DECREF(args);
            Py_XDECREF(result);
            return !result ? -1 : 0;
        </inject-code>
    </add-function>
  </value-type>
  <!-- QReadWriteLock does not have a copy ctor! -->
  <object-type name="QReadWriteLock">
    <enum-type name="RecursionMode"/>
    <modify-function signature="lockForRead()" allow-thread="yes"/>
    <modify-function signature="tryLockForRead(int)" allow-thread="yes"/>
    <modify-function signature="lockForWrite()" allow-thread="yes"/>
    <modify-function signature="tryLockForWrite(int)" allow-thread="yes"/>
  </object-type>
  <object-type name="QReadLocker">
    <modify-function signature="QReadLocker(QReadWriteLock*)">
        <modify-argument index="1">
            <reference-count action="set"/>
        </modify-argument>
    </modify-function>
    <modify-function signature="relock()" allow-thread="yes" />
    <add-function signature="__enter__()" />
    <add-function signature="__exit__(PyObject*, PyObject*, PyObject*)">
        <inject-code>
            %CPPSELF.unlock();
        </inject-code>
    </add-function>
  </object-type>
  <object-type name="QWriteLocker">
    <modify-function signature="QWriteLocker(QReadWriteLock*)">
        <modify-argument index="1">
            <reference-count action="set"/>
        </modify-argument>
    </modify-function>
    <modify-function signature="relock()" allow-thread="yes" />
    <add-function signature="__enter__()" />
    <add-function signature="__exit__(PyObject*, PyObject*, PyObject*)">
        <inject-code>
            %CPPSELF.unlock();
        </inject-code>
    </add-function>
  </object-type>
  <object-type name="QDirIterator">
    <enum-type name="IteratorFlag" flags="IteratorFlags"/>
  </object-type>
  <object-type name="QThread">
    <enum-type name="Priority"/>
    <modify-function signature="run()" thread="yes" />
    <modify-function signature="exec()" rename="exec_" allow-thread="yes" />
    <modify-function signature="msleep(unsigned long)" allow-thread="yes" />
    <modify-function signature="sleep(unsigned long)" allow-thread="yes" />
    <modify-function signature="usleep(unsigned long)" allow-thread="yes" />
    <modify-function signature="wait(unsigned long)" allow-thread="yes" />
    <modify-function signature="start(QThread::Priority)" allow-thread="yes">
      <modify-argument index="1">
        <rename to="priority"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="exit(int)" allow-thread="yes" />
  </object-type>
  <object-type name="QAbstractFileEngineIterator"/>
  <object-type name="QAbstractItemModel">
    <!-- This function was replaced by a added function -->
    <modify-function signature="createIndex(int, int, void*) const" remove="all"/>
    <!-- This function is the same as createIndex(int, int, int) const -->
    <modify-function signature="createIndex(int,int, quint32)const" remove="all" />
    <modify-function signature="createIndex(int, int, int)const">
        <modify-argument index="3">
            <replace-default-expression with="0" />
        </modify-argument>
    </modify-function>
    <add-function signature="createIndex(int, int, PyObject*)const" return-type="QModelIndex">
        <modify-argument index="1">
            <rename to="row"/>
        </modify-argument>
        <modify-argument index="2">
            <rename to="column"/>
        </modify-argument>
        <modify-argument index="3">
            <rename to="ptr"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
        %RETURN_TYPE %0 = %CPPSELF.%FUNCTION_NAME(%1, %2, %PYARG_3);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
        <inject-documentation mode="append" format="target">
            Creates a model index for the given row and column with the internal pointer ptr.
            When using a QSortFilterProxyModel, its indexes have their own internal pointer. It is not advisable to access this internal pointer outside of the model. Use the data() function instead.
            This function provides a consistent interface that model subclasses must use to create model indexes.

            .. warning:: Because of some Qt/Python itegration rules, the ptr argument do not get the reference incremented during the QModelIndex life time. So it is necessary to keep the object used on ptr argument alive during the whole process. Do not destroy the object if you are not sure about that.
        </inject-documentation>
    </add-function>
    <modify-function signature="mimeData(QModelIndexList) const">
      <modify-argument index="return">
        <define-ownership class="native" owner="c++"/>
        <define-ownership class="target" owner="default"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="data(const QModelIndex&amp;,int) const">
      <modify-argument index="return">
        <define-ownership class="native" owner="c++"/>
      </modify-argument>
    </modify-function>
  </object-type>
  <!-- QObject is created manually -->
  <object-type name="QObject">
    <extra-includes>
      <include file-name="QThread" location="global"/>
      <include file-name="QCoreApplication" location="global"/>
      <include file-name="signalmanager.h" location="local" />
    </extra-includes>
    <modify-function signature="metaObject() const">
      <inject-code class="target" position="beginning">
        %RETURN_TYPE %0 = %CPPSELF.%FUNCTION_NAME();
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
      </inject-code>
      <modify-argument index="return">
        <reference-count action="set"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="deleteLater()">
      <modify-argument index="this">
        <define-ownership owner="c++"/>
      </modify-argument>
    </modify-function>
    <!-- Invalidate-after-use stuff -->
    <modify-function signature="childEvent(QChildEvent*)">
        <modify-argument index="1" invalidate-after-use="yes"/>
    </modify-function>
    <modify-function signature="customEvent(QEvent*)">
        <modify-argument index="1" invalidate-after-use="yes"/>
    </modify-function>
    <modify-function signature="event(QEvent*)">
        <modify-argument index="1" invalidate-after-use="yes"/>
    </modify-function>
    <modify-function signature="eventFilter(QObject*,QEvent*)">
        <modify-argument index="2" invalidate-after-use="yes"/>
    </modify-function>
    <modify-function signature="timerEvent(QTimerEvent*)">
        <modify-argument index="1" invalidate-after-use="yes"/>
    </modify-function>
    <!-- End of Invalidate-after-use fix -->
    <modify-function signature="parent() const">
      <modify-argument index="this">
        <parent index="return" action="add"/>
      </modify-argument>
      <modify-argument index="return">
        <define-ownership class="target" owner="default"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="setParent(QObject*)">
      <modify-argument index="this">
        <parent index="1" action="add"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="connect(const QObject*, const char*, const char *, Qt::ConnectionType) const">
        <modify-argument index="4">
            <rename to="type"/>
        </modify-argument>
        <inject-code class="target" position="beginning" file="">
        // %FUNCTION_NAME() - disable generation of function call.
        %RETURN_TYPE %0 = qobjectConnect(%1, %2, %CPPSELF, %3, %4);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </modify-function>
    <modify-function signature="connect(const QObject*, const char*, const QObject*, const char *, Qt::ConnectionType)">
        <modify-argument index="5">
            <rename to="type"/>
        </modify-argument>
        <inject-code class="target" position="beginning" file="">
        // %FUNCTION_NAME() - disable generation of function call.
        %RETURN_TYPE %0 = qobjectConnect(%1, %2, %3, %4, %5);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </modify-function>
    <inject-code class="native" position="beginning" file="glue/qobject_connect.cpp" />
    <add-function signature="connect(const QObject*, const char*, PyCallable*, Qt::ConnectionType)" return-type="bool" static="yes">
        <modify-argument index="4">
            <rename to="type"/>
            <replace-default-expression with="Qt::AutoConnection" />
        </modify-argument>
        <inject-code class="target" position="beginning">
        // %FUNCTION_NAME() - disable generation of function call.
        %RETURN_TYPE %0 = qobjectConnectCallback(%1, %2, %PYARG_3, %4);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </add-function>
    <!-- static version -->
    <add-function signature="connect(const char*, PyCallable*, Qt::ConnectionType)" return-type="bool">
        <modify-argument index="3">
            <rename to="type"/>
            <replace-default-expression with="Qt::AutoConnection" />
        </modify-argument>
        <inject-code class="target" position="beginning">
        // %FUNCTION_NAME() - disable generation of function call.
        %RETURN_TYPE %0 = qobjectConnectCallback(%CPPSELF, %1, %PYARG_2, %3);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </add-function>
    <add-function signature="connect(const char*, const QObject*, const char *, Qt::ConnectionType)" return-type="bool">
        <modify-argument index="4">
            <rename to="type"/>
            <replace-default-expression with="Qt::AutoConnection" />
        </modify-argument>
        <inject-code class="target" position="beginning">
        // %FUNCTION_NAME() - disable generation of function call.
        %RETURN_TYPE %0 = qobjectConnect(%CPPSELF, %1, %2, %3, %4);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </add-function>
    <add-function signature="emit(const char*, ...)" return-type="bool">
        <inject-code class="target" position="beginning">
        %RETURN_TYPE %0 = PySide::SignalManager::instance().emitSignal(%CPPSELF, %1, %PYARG_2);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </add-function>
    <add-function signature="disconnect(const char *, PyCallable*)" return-type="bool">
         <inject-code class="target" position="beginning">
        // %FUNCTION_NAME() - disable generation of function call.
        %RETURN_TYPE %0 = qobjectDisconnectCallback(%CPPSELF, %1, %2);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </add-function>
    <add-function signature="disconnect(const QObject*, const char*, PyCallable*)" return-type="bool" static="yes">
         <inject-code class="target" position="beginning">
        // %FUNCTION_NAME() - disable generation of function call.
        %RETURN_TYPE %0 = qobjectDisconnectCallback(%1, %2, %3);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </add-function>
    <inject-code class="native" file="glue/qobject_findchild.cpp"/>
    <add-function signature="findChild(PyTypeObject*, const QString&amp;)" return-type="PyObject*">
        <inject-code class="target" position="beginning">
        QObject* child = _findChildHelper(%CPPSELF, %2, (PyTypeObject*)%PYARG_1);
        %PYARG_0 = %CONVERTTOPYTHON[QObject*](child);
        </inject-code>
      <modify-argument index="return">
        <parent index="this" action="add"/>
      </modify-argument>
      <modify-argument index="2">
          <replace-default-expression with="QString()" />
      </modify-argument>
    </add-function>
    <add-function signature="findChildren(PyTypeObject*, const QString&amp;)" return-type="PySequence*" >
        <inject-code class="target" position="beginning">
            %PYARG_0 = PyList_New(0);
            _findChildrenHelper(%CPPSELF, %2, (PyTypeObject*)%PYARG_1, %PYARG_0);
        </inject-code>
        <modify-argument index="return">
            <parent index="this" action="add"/>
        </modify-argument>
        <modify-argument index="2">
            <replace-default-expression with="QString()" />
        </modify-argument>
    </add-function>
    <add-function signature="findChildren(PyTypeObject*, const QRegExp&amp;)" return-type="PySequence*" >
        <inject-code class="target" position="beginning">
            %PYARG_0 = PyList_New(0);
            _findChildrenHelper(%CPPSELF, %2, (PyTypeObject*)%PYARG_1, %PYARG_0);
        </inject-code>
        <modify-argument index="return">
            <parent index="this" action="add"/>
        </modify-argument>
    </add-function>

    <add-function signature="tr(const char *, const char *, int)" return-type="QString">
        <modify-argument index="2">
          <replace-default-expression with="0"/>
        </modify-argument>
        <modify-argument index="3">
          <replace-default-expression with="-1"/>
        </modify-argument>

        <inject-code class="target" position="beginning">
            QString result;
            if (QCoreApplication::instance()) {
                PyObject *klass = PyObject_GetAttrString(%PYSELF, "__class__");
                PyObject *cname = PyObject_GetAttrString(klass, "__name__");
                result = QString(QCoreApplication::instance()->translate(Shiboken::String::toCString(cname), %1, %2, QCoreApplication::CodecForTr, %3));

                Py_DECREF(klass);
                Py_DECREF(cname);
            } else {
                result = QString(QString::fromLatin1(%1));
            }
            %PYARG_0 = %CONVERTTOPYTHON[QString](result);
        </inject-code>
    </add-function>

    <template name="translate_utf8">
    if (QCoreApplication::instance()) {
        Shiboken::AutoDecRef klass(PyObject_GetAttrString(%PYSELF, "__class__"));
        Shiboken::AutoDecRef cname(PyObject_GetAttrString(klass, "__name__"));
        $DEFINE_SECOND_VAR
        QString result = QCoreApplication::instance()->translate(Shiboken::String::toCString(cname.object()), $SECOND_VAR, %2, QCoreApplication::UnicodeUTF8, %3);
        %PYARG_0 = %CONVERTTOPYTHON[QString](result);
    } else {
        Py_INCREF(%PYARG_1);
        %PYARG_0 = %PYARG_1;
    }
    </template>
    <add-function signature="trUtf8(const char *, const char *, int)" return-type="QString">
        <modify-argument index="2">
          <replace-default-expression with="0"/>
        </modify-argument>
        <modify-argument index="3">
          <replace-default-expression with="-1"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="translate_utf8">
                <replace from="$DEFINE_SECOND_VAR" to="" />
                <replace from="$SECOND_VAR" to="%1" />
            </insert-template>
        </inject-code>
    </add-function>
    <add-function signature="trUtf8(PyUnicode, const char *, int)" return-type="QString">
        <modify-argument index="2">
          <replace-default-expression with="0"/>
        </modify-argument>
        <modify-argument index="3">
          <replace-default-expression with="-1"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="translate_utf8">
                <replace from="$DEFINE_SECOND_VAR" to="Shiboken::AutoDecRef str(PyUnicode_AsUTF8String(%1));" />
                <replace from="$SECOND_VAR" to="Shiboken::String::toCString(str.object())" />
            </insert-template>
        </inject-code>
    </add-function>

   <modify-function signature="receivers(const char*) const">
     <inject-code class="target" position="beginning">
       // Avoid return +1 because SignalManager connect to "destroyed()" signal to control object timelife
       int ret = %CPPSELF.%FUNCTION_NAME(%1);
       if (ret > 0 &amp;&amp; ((strcmp(%1, SIGNAL(destroyed())) == 0) || (strcmp(%1, SIGNAL(destroyed(QObject*))) == 0)))
       ret -= PySide::SignalManager::instance().countConnectionsWith(%CPPSELF);

       %PYARG_0 = %CONVERTTOPYTHON[int](ret);
     </inject-code>
   </modify-function>

   <modify-function signature="destroyed(QObject*)">
     <modify-argument index="1">
       <rename to="object"/>
     </modify-argument>
   </modify-function>

   <modify-function signature="sender() const">
      <modify-argument index="return">
         <define-ownership owner="default"/>
      </modify-argument>
  </modify-function>

   <!-- This is not supported due the lack of information durring the call with no arguments,  this can cause a memory leak -->
   <modify-function signature="disconnect(const char*, const QObject *, const char *)">
       <modify-argument index="1">
           <remove-default-expression />
       </modify-argument>
       <modify-argument index="2">
           <remove-default-expression />
       </modify-argument>
       <modify-argument index="3">
           <remove-default-expression />
       </modify-argument>
   </modify-function>
  </object-type>
  <object-type name="QAbstractListModel" polymorphic-id-expression="qobject_cast&lt;QAbstractListModel*&gt;(%1)">
    <extra-includes>
      <include file-name="QStringList" location="global"/>
      <include file-name="QSize" location="global"/>
    </extra-includes>
  </object-type>
  <value-type name="QUrl" hash-function="PySide::hash">
    <enum-type name="FormattingOption" flags="FormattingOptions"/>
    <enum-type name="ParsingMode"/>
    <modify-documentation xpath='description/para[3]'>
        &lt;para>URLs can be represented in two forms: encoded or unencoded. The unencoded representation is suitable for showing to users, but the encoded representation is typically what you would send to a web server. For example, the unencoded URL &quot;http://bhler.example.com&quot; would be sent to the server as &quot;http://xn--bhler-kva.example.com/List%20of%20applicants.xml&quot;.&lt;/para>
    </modify-documentation>
    <extra-includes>
      <include file-name="QStringList" location="global"/>
    </extra-includes>
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="'%s'" />
               <replace from="%REPR_ARGS" to="qPrintable(%CPPSELF.toString())" />
             </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="s" />
              <replace from="%REDUCE_ARGS" to="qPrintable(%CPPSELF.toString())" />
            </insert-template>
        </inject-code>
    </add-function>
  </value-type>
  <value-type name="QRegExp">
    <enum-type name="CaretMode"/>
    <enum-type name="PatternSyntax"/>
    <extra-includes>
      <include file-name="QStringList" location="global"/>
    </extra-includes>
    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="repr_code">
               <replace from="%REPR_FORMAT" to="'%s', %i, %i" />
               <replace from="%REPR_ARGS" to="qPrintable(%CPPSELF.pattern()), (int)%CPPSELF.caseSensitivity(), (int)%CPPSELF.patternSyntax()" />
             </insert-template>
        </inject-code>
    </add-function>

    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="sii" />
              <replace from="%REDUCE_ARGS" to="qPrintable(%CPPSELF.pattern()), (int)%CPPSELF.caseSensitivity(), (int)%CPPSELF.patternSyntax()" />
            </insert-template>
        </inject-code>
    </add-function>
    <add-function signature="replace(QString, QString)" return-type="QString">
        <modify-argument index="1">
            <rename to="sourceString"/>
        </modify-argument>
        <modify-argument index="2">
            <rename to="after"/>
        </modify-argument>
        <inject-documentation format="target" mode="append">
        Replaces every occurrence of the regular expression in *sourceString* with *after*.
        Returns a new Python string with the modified contents. For example:

        ::

            s = "Banana"
            re = QRegExp("a[mn]")
            s = re.replace(s, "ox")
            # s == "Boxoxa"


        For regular expressions containing capturing parentheses, occurrences of \1, \2, ..., in *after*
        are replaced with rx.cap(1), cap(2), ...

        ::

            t = "A &lt;i>bon mot&lt;/i>."
            re = QRegExp("&lt;i>([^&lt;]*)&lt;/i>")
            t = re.replace(t, "\\emph{\\1}")
            # t == "A \\emph{bon mot}."

        </inject-documentation>
        <inject-code class="target" position="beginning">
        %1.replace(*%CPPSELF, %2);
        %PYARG_0 = %CONVERTTOPYTHON[QString](%1);
        </inject-code>
    </add-function>
  </value-type>
  <value-type name="QFileInfo">
    <extra-includes>
      <include file-name="QDateTime" location="global"/>
      <include file-name="QDir" location="global"/>
    </extra-includes>
    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
              <replace from="%REDUCE_FORMAT" to="s" />
              <replace from="%REDUCE_ARGS" to="qPrintable(%CPPSELF.filePath())" />
            </insert-template>
        </inject-code>
    </add-function>
  </value-type>
  <value-type name="QByteArray" hash-function="qHash">
    <conversion-rule>
        <target-to-native>
            <add-conversion type="Py_None">
            %out = %OUTTYPE();
            </add-conversion>
            <add-conversion type="PyString" check="Shiboken::String::check(%in)">
            %out = %OUTTYPE(Shiboken::String::toCString(%in), Shiboken::String::len(%in));
            </add-conversion>
            <add-conversion type="PyBytes">
            #ifdef IS_PY3K
            %out = %OUTTYPE(PyBytes_AS_STRING(%in), PyBytes_GET_SIZE(%in));
            #endif
            </add-conversion>
        </target-to-native>
    </conversion-rule>

    <extra-includes>
      <include file-name="QNoImplicitBoolCast" location="global"/>
    </extra-includes>

    <!-- ### These overloads must be removed accept strings with \x00 in their contents -->
    <modify-function signature="append(const char*,int)" remove="all" />
    <modify-function signature="append(const char*)" remove="all" />
    <modify-function signature="append(QString)" remove="all" />
    <modify-function signature="contains(const char*)const" remove="all" />
    <modify-function signature="count(const char*)const" remove="all" />
    <modify-function signature="endsWith(const char*)const" remove="all" />
    <modify-function signature="indexOf(const char*,int)const" remove="all" />
    <modify-function signature="indexOf(char,int)const" remove="all" />
    <modify-function signature="indexOf(QString,int)const" remove="all" />
    <modify-function signature="insert(int,const char*)" remove="all" />
    <modify-function signature="insert(int,char)" remove="all" />
    <modify-function signature="insert(int,const char*,int)" since="4.6" remove="all" />
    <modify-function signature="insert(int,QString)" remove="all" />
    <modify-function signature="lastIndexOf(const char*,int)const" remove="all" />
    <modify-function signature="lastIndexOf(QString,int)const" remove="all" />
    <modify-function signature="lastIndexOf(char,int)const" remove="all" />
    <modify-function signature="prepend(const char*)" remove="all" />
    <modify-function signature="prepend(const char*,int)" since="4.6" remove="all" />
    <modify-function signature="replace(QByteArray,const char*)" remove="all" />
    <modify-function signature="replace(const char*,int,const char*,int)" remove="all"/>
    <modify-function signature="replace(QString,const char*)" remove="all" />
    <modify-function signature="replace(const char*,QByteArray)" remove="all" />
    <modify-function signature="replace(const char*,const char*)" remove="all" />
    <modify-function signature="replace(int,int,const char*)" remove="all" />
    <modify-function signature="replace(int,int,const char*,int)" since="4.6" remove="all" />
    <modify-function signature="replace(char,const char*)" remove="all" />
    <modify-function signature="replace(char,QString)" remove="all" />
    <modify-function signature="startsWith(const char*)const" remove="all" />
    <modify-function signature="operator==(QString)const" remove="all" />
    <modify-function signature="operator==(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator==(QByteArray, const char*)" remove="all" />
    <modify-function signature="operator>(QString)const" remove="all" />
    <modify-function signature="operator>(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator>(QByteArray,const char*)" remove="all" />
    <modify-function signature="operator>=(QString)const" remove="all" />
    <modify-function signature="operator>=(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator>=(QByteArray,const char*)" remove="all" />
    <modify-function signature="operator&lt;(QString)const" remove="all" />
    <modify-function signature="operator&lt;(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator&lt;=(QString)const" remove="all" />
    <modify-function signature="operator&lt;=(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator&lt;=(QByteArray,const char*)" remove="all" />
    <modify-function signature="operator!=(QString)const" remove="all" />
    <modify-function signature="operator!=(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator!=(QByteArray,const char*)" remove="all" />
    <modify-function signature="operator+=(QString)" remove="all" />
    <modify-function signature="operator+=(const char*)" remove="all" />
    <modify-function signature="operator+(QByteArray,const char*)" remove="all" />
    <modify-function signature="operator+(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator+(QByteArray,const char*)" remove="all" />
    <modify-function signature="operator+(QString,QByteArray)" remove="all" />
    <modify-function signature="operator+(QByteArray,QString)" remove="all" />
    <add-function signature="operator+(PyUnicode)">
        <inject-code>
            Shiboken::AutoDecRef str(PyUnicode_AsASCIIString(%PYARG_1));
            if (!str.isNull()) {
                QByteArray b(PyBytes_AS_STRING(str.object()), PyBytes_GET_SIZE (str.object()));
                b.prepend(*%CPPSELF);
                %PYARG_0 = %CONVERTTOPYTHON[QByteArray](b);
            }
        </inject-code>
    </add-function>
    <add-function signature="operator+(PyUnicode, QByteArray)">
        <inject-code>
            Shiboken::AutoDecRef str(PyUnicode_AsASCIIString(%PYARG_1));
            if (!str.isNull()) {
                QByteArray b(PyBytes_AS_STRING(str.object()), PyBytes_GET_SIZE(str.object()));
                b.append(*%CPPSELF);
                %PYARG_0 = %CONVERTTOPYTHON[QByteArray](b);
            }
        </inject-code>
    </add-function>
    <add-function signature="operator+(PyBytes, QByteArray)">
        <inject-code>
        QByteArray ba = QByteArray(PyBytes_AS_STRING(%PYARG_1), PyBytes_GET_SIZE(%PYARG_1)) + *%CPPSELF;
        %PYARG_0 = %CONVERTTOPYTHON[QByteArray](ba);
        </inject-code>
    </add-function>
    <!-- ### -->

    <add-function signature="__repr__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            QByteArray b(((PyObject*)%PYSELF)->ob_type->tp_name);
            PyObject* aux = Shiboken::String::fromStringAndSize(%CPPSELF.constData(), %CPPSELF.size());
            if (PyUnicode_CheckExact(aux)) {
                PyObject* tmp = PyUnicode_AsASCIIString(aux);
                Py_DECREF(aux);
                aux = tmp;
            }
            b += "('";
            b += QByteArray(PyBytes_AS_STRING(aux), PyBytes_GET_SIZE(aux));
            b += "')";
            %PYARG_0 = Shiboken::String::fromStringAndSize(b.constData(), b.size());
        </inject-code>
    </add-function>

    <add-function signature="__reduce__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            <insert-template name="reduce_code">
                <replace from="%REDUCE_FORMAT" to="N" />
                <replace from="%REDUCE_ARGS" to="PyBytes_FromStringAndSize(%CPPSELF.constData(), %CPPSELF.size())" />
            </insert-template>
        </inject-code>
    </add-function>
    <modify-function signature="QByteArray(const char *)">
        <!-- Keep \x00 bytes passed in python strings -->
        <inject-code class="target" position="beginning">
            if (PyBytes_Check(%PYARG_1)) {
                %0 = new QByteArray(PyBytes_AsString(%PYARG_1), PyBytes_GET_SIZE(%PYARG_1));
            } if (PyUnicode_CheckExact(%PYARG_1)) {
                Shiboken::AutoDecRef data(PyUnicode_AsASCIIString(%PYARG_1));
                %0 = new QByteArray(PyBytes_AsString(data.object()), PyBytes_GET_SIZE(data.object()));
            } else if (Shiboken::String::check(%PYARG_1)) {
                %0 = new QByteArray(Shiboken::String::toCString(%PYARG_1), Shiboken::String::len(%PYARG_1));
            }
        </inject-code>
    </modify-function>
    <!-- buffer protocol -->
    <inject-code class="native" position="beginning" file="glue/qbytearray_bufferprotocol.cpp" />
    <inject-code class="target" position="end">
        #if PY_VERSION_HEX &lt; 0x03000000
            Shiboken::SbkType&lt;QByteArray>()->tp_as_buffer = &amp;SbkQByteArrayBufferProc;
            Shiboken::SbkType&lt;QByteArray>()->tp_flags |= Py_TPFLAGS_HAVE_GETCHARBUFFER;
        #endif
    </inject-code>

   <modify-function signature="data()">
       <inject-code class="target" position="beginning">
           %PYARG_0 = PyBytes_FromStringAndSize(%CPPSELF.%FUNCTION_NAME(), %CPPSELF.size());
       </inject-code>
   </modify-function>

    <!-- removed functions -->
    <!--### Functions removed because they return STL-like iterators -->
    <modify-function signature="begin()" remove="all"/>
    <modify-function signature="begin()const" remove="all"/>
    <modify-function signature="constBegin()const" remove="all"/>
    <modify-function signature="constData()const" remove="all"/>
    <modify-function signature="constEnd()const" remove="all"/>
    <modify-function signature="end()" remove="all"/>
    <modify-function signature="end()const" remove="all"/>
    <!--### -->

    <!--### Functions removed because they provide useless overloads from Python point of view -->
    <modify-function signature="number(uint,int)" remove="all"/>
    <modify-function signature="number(qulonglong,int)" remove="all"/>
    <modify-function signature="operator+=(const char*)" remove="all"/>
    <modify-function signature="operator==(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator!=(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator&lt;(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator&lt;=(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator>(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator>=(const char*,QByteArray)" remove="all" />
    <modify-function signature="operator[](int)const" remove="all"/>
    <modify-function signature="operator[](uint)const" remove="all"/>
    <!-- Those types have the same representation in Python, an overload would be useless. -->
    <modify-function signature="setNum(uint,int)" remove="all"/>
    <modify-function signature="setNum(ushort,int)" remove="all"/>
    <modify-function signature="setNum(float,char,int)" remove="all"/>
    <modify-function signature="setNum(short,int)" remove="all"/>
    <modify-function signature="setNum(qulonglong,int)" remove="all"/>

    <!--### -->

    <modify-function signature="operator const char *()const" remove="all"/>
    <modify-function signature="operator const void *()const" remove="all"/>

    <!--### STL compatibility functions not supported by PySide -->
    <modify-function signature="push_back(char)" remove="all"/>
    <modify-function signature="push_back(const QByteArray&amp;)" remove="all"/>
    <modify-function signature="push_back(const char*)" remove="all"/>
    <modify-function signature="push_front(char)" remove="all"/>
    <modify-function signature="push_front(const QByteArray&amp;)" remove="all"/>
    <modify-function signature="push_front(const char*)" remove="all"/>
    <!--### -->

    <modify-function signature="toLong(bool*, int) const">
      <modify-argument index="1">
        <remove-argument/>
      </modify-argument>
      <inject-code class="target" position="beginning">
        <insert-template name="fix_bool*,arg"/>
      </inject-code>
    </modify-function>
    <modify-function signature="toLongLong(bool*, int) const">
      <modify-argument index="1">
        <remove-argument/>
      </modify-argument>
      <inject-code class="target" position="beginning">
        <insert-template name="fix_bool*,arg"/>
      </inject-code>
    </modify-function>
    <modify-function signature="toShort(bool*, int) const">
      <modify-argument index="1">
        <remove-argument/>
      </modify-argument>
      <inject-code class="target" position="beginning">
        <insert-template name="fix_bool*,arg"/>
      </inject-code>
    </modify-function>
    <modify-function signature="toUInt(bool*, int) const">
      <modify-argument index="1">
        <remove-argument/>
      </modify-argument>
      <inject-code class="target" position="beginning">
        <insert-template name="fix_bool*,arg"/>
      </inject-code>
    </modify-function>
    <modify-function signature="toULong(bool*, int) const">
      <modify-argument index="1">
        <remove-argument/>
      </modify-argument>
      <inject-code class="target" position="beginning">
        <insert-template name="fix_bool*,arg"/>
      </inject-code>
    </modify-function>
    <modify-function signature="toULongLong(bool*, int) const">
      <modify-argument index="1">
        <remove-argument/>
      </modify-argument>
      <inject-code class="target" position="beginning">
        <insert-template name="fix_bool*,arg"/>
      </inject-code>
    </modify-function>
    <modify-function signature="toInt(bool*,int)const">
      <modify-argument index="1">
        <remove-argument/>
      </modify-argument>
      <inject-code class="target" position="beginning">
        <insert-template name="fix_bool*,arg"/>
      </inject-code>
    </modify-function>
    <modify-function signature="toUShort(bool*,int)const">
      <modify-argument index="1">
        <remove-argument/>
      </modify-argument>
      <inject-code class="target" position="beginning">
        <insert-template name="fix_bool*,arg"/>
      </inject-code>
    </modify-function>
    <!-- QByteArray(const char *) do the job of this constructor -->
    <modify-function signature="QByteArray(const char*,int)" remove="all"/>
    <modify-function signature="fromRawData(const char*,int)">
        <modify-argument index="1">
            <replace-type modified-type="PyBytes"/>
        </modify-argument>
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <inject-code class="target">
        %RETURN_TYPE %0 = %CPPSELF.%FUNCTION_NAME(PyBytes_AsString(%PYARG_1), PyBytes_GET_SIZE(%PYARG_1));
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </modify-function>
    <modify-function signature="toDouble(bool*)const">
      <modify-argument index="1">
        <remove-argument/>
      </modify-argument>
      <inject-code class="target" position="beginning">
        <insert-template name="fix_bool*"/>
      </inject-code>
    </modify-function>
    <modify-function signature="toFloat(bool*)const">
      <modify-argument index="1">
        <remove-argument/>
      </modify-argument>
      <inject-code class="target" position="beginning">
        <insert-template name="fix_bool*"/>
      </inject-code>
    </modify-function>
    <add-function signature="__str__" return-type="PyObject*">
        <inject-code class="target" position="beginning">
            %PYARG_0 = Shiboken::String::fromStringAndSize(%CPPSELF.constData(), %CPPSELF.size());
        </inject-code>
    </add-function>
    <add-function signature="__len__">
        <inject-code class="target" position="beginning">
            return %CPPSELF.count();
        </inject-code>
    </add-function>
    <add-function signature="__getitem__">
        <inject-code class="target" position="beginning">
                if (_i &lt; 0 || _i >= %CPPSELF.size()) {
                    PyErr_SetString(PyExc_IndexError, "index out of bounds");
                    return 0;
                } else {
                    char res[2];
                    res[0] = %CPPSELF.at(_i);
                    res[1] = 0;
                    return PyBytes_FromStringAndSize(res, 1);
                }
        </inject-code>
    </add-function>
    <add-function signature="__setitem__">
        <inject-code class="target" position="beginning">
                %CPPSELF.remove(_i, 1);
                PyObject* args = Py_BuildValue("(nO)", _i, _value);
                PyObject* result = Sbk_QByteArrayFunc_insert(self, args);
                Py_DECREF(args);
                Py_XDECREF(result);
                return !result ? -1 : 0;
        </inject-code>
    </add-function>
    <add-function signature="__getslice__">
        <inject-code class="target" position="beginning">
            Py_ssize_t max = %CPPSELF.count();
            _i1 = qBound(Py_ssize_t(0), _i1, max);
            _i2 = qBound(Py_ssize_t(0), _i2, max);
            QByteArray ba;
            if (_i1 &lt; _i2)
                ba = %CPPSELF.mid(_i1, _i2 - _i1);
            return %CONVERTTOPYTHON[QByteArray](ba);
        </inject-code>
    </add-function>
  </value-type>
  <value-type name="QTextBoundaryFinder">
    <enum-type name="BoundaryReason" flags="BoundaryReasons"/>
    <enum-type name="BoundaryType"/>
    <!-- There's no QChar in PySide -->
    <modify-function signature="QTextBoundaryFinder(QTextBoundaryFinder::BoundaryType,const QChar*,int,unsigned char*,int)" remove="all"/>
  </value-type>
  <object-type name="QXmlStreamEntityResolver"/>
  <object-type name="QAbstractEventDispatcher">
    <extra-includes>
      <include file-name="QPair" location="global"/>
    </extra-includes>
    <modify-function signature="processEvents(QFlags&lt;QEventLoop::ProcessEventsFlag>)" allow-thread="yes"/>
  </object-type>
  <object-type name="QEventLoop">
      <enum-type name="ProcessEventsFlag" flags="ProcessEventsFlags"/>
      <modify-function signature="exec(QFlags&lt;QEventLoop::ProcessEventsFlag>)" rename="exec_" allow-thread="yes" />
      <modify-function signature="processEvents(QFlags&lt;QEventLoop::ProcessEventsFlag>)" allow-thread="yes" />
      <modify-function signature="processEvents(QFlags&lt;QEventLoop::ProcessEventsFlag>, int)" allow-thread="yes" />
  </object-type>
  <object-type name="QFile">
    <enum-type name="FileError"/>
    <enum-type name="MemoryMapFlags"/>
    <enum-type name="Permission" flags="Permissions"/>
    <enum-type name="FileHandleFlag" flags="FileHandleFlags" since="4.8" revision="4800"/>
    <extra-includes>
      <include file-name="QAbstractFileEngine" location="global"/>
    </extra-includes>
    <modify-function signature="unmap(uchar*)">
        <modify-argument index="1">
            <replace-type modified-type="PyBuffer"/>
        </modify-argument>
        <inject-code>
        uchar* ptr = (uchar*) Shiboken::Buffer::getPointer(%PYARG_1);
        %RETURN_TYPE %0 = %CPPSELF.%FUNCTION_NAME(ptr);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </modify-function>
    <modify-function signature="map(qint64,qint64,QFile::MemoryMapFlags)">
        <modify-argument index="return">
            <replace-type modified-type="PyObject"/>
        </modify-argument>
        <inject-code>
            %PYARG_0 = Shiboken::Buffer::newObject(%CPPSELF.%FUNCTION_NAME(%1, %2, %3), %2, Shiboken::Buffer::ReadWrite);
        </inject-code>
    </modify-function>
    <modify-function signature="remove()" allow-thread="yes"/>
    <modify-function signature="remove(const QString&amp;)" allow-thread="yes"/>
    <modify-function signature="rename(const QString&amp;)" allow-thread="yes"/>
    <modify-function signature="rename(const QString&amp;, const QString&amp;)" allow-thread="yes"/>
    <modify-function signature="link(const QString&amp;)" allow-thread="yes"/>
    <modify-function signature="link(const QString&amp;, const QString&amp;)" allow-thread="yes"/>
    <modify-function signature="copy(const QString&amp;)" allow-thread="yes"/>
    <modify-function signature="copy(const QString&amp;, const QString&amp;)" allow-thread="yes"/>
    <modify-function signature="flush()" allow-thread="yes"/>
  </object-type>
  <object-type name="QIODevice">
    <enum-type name="OpenModeFlag" flags="OpenMode"/>
    <modify-function signature="open(QFlags&lt;QIODevice::OpenModeFlag>)" allow-thread="yes"/>
    <modify-function signature="close()" allow-thread="yes"/>
    <modify-function signature="seek(qint64)" allow-thread="yes"/>
    <modify-function signature="readAll()" allow-thread="yes"/>
    <modify-function signature="peek(qint64)" allow-thread="yes"/>
    <modify-function signature="write(const QByteArray&amp;)" allow-thread="yes"/>
    <modify-function signature="waitForReadyRead(int)" allow-thread="yes"/>
    <modify-function signature="waitForBytesWritten(int)" allow-thread="yes"/>
    <!-- ### peek(qint64) do the job -->
    <modify-function signature="peek(char*, qint64)" remove="all"/>
    <!-- ### read(qint64) do the job -->
    <modify-function signature="read(char*, qint64)" remove="all"/>
    <!-- ### readLine(qint64) do the job -->
    <modify-function signature="readLine(char*, qint64)" remove="all"/>
    <!-- ### write(str) do the job -->
    <modify-function signature="write(const char*, qint64)" remove="all"/>
    <modify-function signature="write(const char*)" remove="all"/>
    <modify-function signature="getChar(char*)">
        <modify-argument index="1">
            <remove-argument />
            <remove-default-expression />
        </modify-argument>
        <inject-code class="target" position="beginning">
            <insert-template name="fix_char*" />
        </inject-code>
    </modify-function>
    <modify-function signature="readData(char*, qint64)">
        <inject-code class="target">
            QByteArray ba;
            ba.resize(%2);
            %CPPSELF.%FUNCTION_NAME(ba.data(), ba.size());
            %PYARG_0 = %CONVERTTOPYTHON[QByteArray](ba);
        </inject-code>
        <modify-argument index="1">
            <remove-argument />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="PyObject"/>
            <conversion-rule class="native">
                %RETURN_TYPE %out;
                if (PyBytes_Check(%PYARG_0)) {
                    %out = PyBytes_GET_SIZE((PyObject*)%PYARG_0);
                    memcpy(%1, PyBytes_AS_STRING((PyObject*)%PYARG_0), %out);
                } else if (Shiboken::String::check(%PYARG_0)) {
                    %out = Shiboken::String::len((PyObject*)%PYARG_0);
                    memcpy(%1, Shiboken::String::toCString((PyObject*)%PYARG_0), %out);
                }
            </conversion-rule>
        </modify-argument>
    </modify-function>
    <modify-function signature="readLineData(char*, qint64)">
        <inject-code class="target">
            QByteArray ba;
            ba.resize(%2);
            %CPPSELF.%FUNCTION_NAME(ba.data(), ba.size());
            %PYARG_0 = %CONVERTTOPYTHON[QByteArray](ba);
        </inject-code>
        <modify-argument index="1">
            <remove-argument />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="PyObject"/>
            <conversion-rule class="native">
                %RETURN_TYPE %out;
                if (!PyBytes_Check(%PYARG_0)) {
                    %out = -1;
                } else {
                    %out = PyBytes_GET_SIZE((PyObject*)%PYARG_0);
                    memcpy(%1, PyBytes_AS_STRING((PyObject*)%PYARG_0), %out);
                }
            </conversion-rule>
        </modify-argument>
    </modify-function>
  </object-type>
  <object-type name="QCryptographicHash">
    <enum-type name="Algorithm"/>
    <modify-function signature="addData(const char*,int)">
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <inject-code>
            %CPPSELF.%FUNCTION_NAME(Shiboken::String::toCString(%PYARG_1), Shiboken::String::len(%PYARG_1));
        </inject-code>
    </modify-function>
  </object-type>
  <object-type name="QLibraryInfo">
    <enum-type name="LibraryLocation"/>
  </object-type>
  <object-type name="QMutexLocker" copyable="no">
    <modify-function signature="QMutexLocker(QMutex*)" allow-thread="yes">
        <modify-argument index="1">
            <reference-count action="set" variable-name="mutex()const0"/>
        </modify-argument>
    </modify-function>
    <modify-function signature="relock()" allow-thread="yes"/>
    <modify-function signature="mutex() const">
      <modify-argument index="return">
        <reference-count action="set"/>
      </modify-argument>
    </modify-function>
    <add-function signature="__enter__()" />
    <add-function signature="__exit__(PyObject*, PyObject*, PyObject*)">
        <inject-code>
            %CPPSELF.unlock();
        </inject-code>
    </add-function>
  </object-type>

  <object-type name="QMutex">
    <enum-type name="RecursionMode"/>
    <modify-function signature="lock()" allow-thread="yes"/>
    <modify-function signature="tryLock(int)" allow-thread="yes"/>
    <modify-function signature="tryLock()" allow-thread="yes"/>
  </object-type>
  <object-type name="QSemaphore">
    <modify-function signature="acquire(int)" allow-thread="yes"/>
    <modify-function signature="tryAcquire(int, int)" allow-thread="yes"/>
  </object-type>
  <object-type name="QSocketNotifier">
    <enum-type name="Type"/>
    <add-function signature="QSocketNotifier(PyObject*, QSocketNotifier::Type, QObject*)">
        <modify-argument index="3">
            <replace-default-expression with="0" />
            <rename to="parent" />
        </modify-argument>
        <inject-code>
        Shiboken::AutoDecRef fileNo(PyObject_GetAttrString(%PYARG_1, "fileno"));
        if (!fileNo.isNull()) {
            Shiboken::AutoDecRef fileNoValue(PyObject_CallObject(fileNo, 0));
            if (%CHECKTYPE[int](fileNoValue)) {
                int cppFileNoValue = %CONVERTTOCPP[int](fileNoValue);
                %0 = new %TYPE(cppFileNoValue, %2, %3);
            }
        }
        </inject-code>
    </add-function>
  </object-type>
  <object-type name="QSystemLocale">
    <enum-type name="QueryType"/>
  </object-type>
  <object-type name="QSysInfo">
    <enum-type name="Endian"/>
    <enum-type name="Sizes"/>
  </object-type>
  <object-type name="QTemporaryFile">
    <extra-includes>
      <include file-name="QAbstractFileEngine" location="global"/>
    </extra-includes>
    <modify-function signature="createLocalFile(const QString&amp;)" allow-thread="yes"/>
  </object-type>
  <object-type name="QMimeData">
    <extra-includes>
      <include file-name="QStringList" location="global"/>
      <include file-name="QUrl" location="global"/>
    </extra-includes>
  </object-type>
  <object-type name="QTextCodec">
    <enum-type name="ConversionFlag" flags="ConversionFlags"/>

    <object-type name="ConverterState">
      <include file-name="QTextCodec" location="global"/>
      <modify-function signature="ConverterState(QFlags&lt;QTextCodec::ConversionFlag&gt;)">
        <modify-argument index="1">
          <replace-default-expression with="QTextCodec::DefaultConversion"/>
        </modify-argument>
      </modify-function>
    </object-type>

    <modify-function signature="setCodecForTr(QTextCodec*)">
      <modify-argument index="1">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="setCodecForCStrings(QTextCodec*)">
      <modify-argument index="1">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="setCodecForLocale(QTextCodec*)">
      <modify-argument index="1">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>
    <!-- fromUnicode(QString) does the job -->
    <modify-function signature="fromUnicode(const QChar*,int,QTextCodec::ConverterState*)const" remove="all" />
    <modify-function signature="convertFromUnicode(const QChar*,int,QTextCodec::ConverterState*)const" remove="all" />
  </object-type>
  <object-type name="QTextDecoder">
    <!-- ### toUnicode(QByteArray) to the job -->
    <modify-function signature="toUnicode(const char*,int)" remove="all" />
    <modify-function signature="toUnicode(QString*,const char*,int)" remove="all" />
    <!-- ### -->
  </object-type>
  <object-type name="QTextEncoder">
    <!-- fromUnicode(QString) does the job -->
    <modify-function signature="fromUnicode(const QChar*,int)" remove="all" />
  </object-type>
  <object-type name="QTimeLine">
    <enum-type name="CurveShape"/>
    <enum-type name="Direction"/>
    <enum-type name="State"/>
  </object-type>
  <object-type name="QTranslator">
    <modify-function signature="load(const uchar*, int)">
        <modify-argument index="1">
            <replace-type modified-type="PyBuffer" />
        </modify-argument>
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <inject-code>
        Py_ssize_t size;
        uchar* ptr = (uchar*) Shiboken::Buffer::getPointer(%PYARG_1, &amp;size);
        %RETURN_TYPE %0 = %CPPSELF.%FUNCTION_NAME(const_cast&lt;const uchar*>(ptr), size);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </modify-function>
  </object-type>
  <object-type name="QWaitCondition">
    <modify-function signature="wait(QMutex*, unsigned long)" allow-thread="yes"/>
    <modify-function signature="wait(QReadWriteLock*, unsigned long)" allow-thread="yes"/>
  </object-type>
  <object-type name="QFileSystemWatcher">
    <extra-includes>
      <include file-name="QStringList" location="global"/>
    </extra-includes>
  </object-type>
  <object-type name="QBuffer">
    <!-- ### setData(QByteArray) do the job -->
    <modify-function signature="setData(const char*,int)" remove="all"/>
  </object-type>
  <object-type name="QTimer">
    <modify-function signature="singleShot(int,QObject*,const char*)">
      <inject-code class="target" position="beginning">
        // %FUNCTION_NAME() - disable generation of c++ function call
        (void) %2; // remove warning about unused variable
        Shiboken::AutoDecRef emptyTuple(PyTuple_New(0));
        PyObject* pyTimer = Shiboken::SbkType&lt;QTimer>()->tp_new(Shiboken::SbkType&lt;QTimer>(), emptyTuple, 0);
        Shiboken::SbkType&lt;QTimer>()->tp_init(pyTimer, emptyTuple, 0);

        QTimer* timer = %CONVERTTOCPP[QTimer*](pyTimer);
        Shiboken::AutoDecRef result(
            PyObject_CallMethod(pyTimer,
                                const_cast&lt;char*>("connect"),
                                const_cast&lt;char*>("OsOs"),
                                pyTimer,
                                SIGNAL(timeout()),
                                %PYARG_2,
                                %3)
        );
        Shiboken::Object::releaseOwnership((SbkObject*)pyTimer);
        Py_XDECREF(pyTimer);
        timer->setSingleShot(true);
        timer->connect(timer, SIGNAL(timeout()), timer, SLOT(deleteLater()));
        timer->start(%1);
      </inject-code>
    </modify-function>
    <add-function signature="singleShot(int, PyCallable*)" static="yes">
        <inject-code class="target" position="beginning">
        // %FUNCTION_NAME() - disable generation of c++ function call
        Shiboken::AutoDecRef emptyTuple(PyTuple_New(0));
        PyObject *pyTimer = Shiboken::SbkType&lt;QTimer>()->tp_new(Shiboken::SbkType&lt;QTimer>(), emptyTuple, 0);
        Shiboken::SbkType&lt;QTimer>()->tp_init(pyTimer, emptyTuple, 0);
        QTimer* timer = %CONVERTTOCPP[QTimer*](pyTimer);
        timer->setSingleShot(true);

        if (PyObject_TypeCheck(%2, &amp;PySideSignalInstanceType)) {
            PySideSignalInstance* signalInstance = reinterpret_cast&lt;PySideSignalInstance*&gt;(%2);
            Shiboken::AutoDecRef signalSignature(Shiboken::String::fromFormat("2%s", PySide::Signal::getSignature(signalInstance)));
            Shiboken::AutoDecRef result(
                PyObject_CallMethod(pyTimer,
                                    const_cast&lt;char*>("connect"),
                                    const_cast&lt;char*>("OsOO"),
                                    pyTimer,
                                    SIGNAL(timeout()),
                                    PySide::Signal::getObject(signalInstance),
                                    signalSignature.object())
            );
        } else {
            Shiboken::AutoDecRef result(
                PyObject_CallMethod(pyTimer,
                                    const_cast&lt;char*>("connect"),
                                    const_cast&lt;char*>("OsO"),
                                    pyTimer,
                                    SIGNAL(timeout()),
                                    %PYARG_2)
            );
        }

        timer->connect(timer, SIGNAL(timeout()), timer, SLOT(deleteLater()), Qt::DirectConnection);
        Shiboken::Object::releaseOwnership((SbkObject*)pyTimer);
        Py_XDECREF(pyTimer);
        timer->start(%1);
        </inject-code>
    </add-function>
  </object-type>
  <object-type name="QAbstractFileEngineHandler">
      <modify-function signature="create(const QString&map;)const">
        <modify-argument index="return">
            <define-ownership owner="c++"/>
        </modify-argument>
      </modify-function>
  </object-type>
  <!-- <object-type name="QAbstractFileEngine::MapExtensionOption" /> -->
  <!-- <object-type name="QAbstractFileEngine::MapExtensionReturn" /> -->
  <!-- <object-type name="QAbstractFileEngine::UnMapExtensionOption" /> -->
  <object-type name="QAbstractFileEngine">
    <enum-type name="Extension" extensible="yes"/>
    <enum-type name="FileFlag" flags="FileFlags"/>
    <enum-type name="FileName"/>
    <enum-type name="FileOwner"/>
    <enum-type name="FileTime"/>
    <extra-includes>
      <include file-name="QDateTime" location="global"/>
    </extra-includes>

    <modify-function signature="open(QFlags&lt;QIODevice::OpenModeFlag>)" allow-thread="yes" />
    <modify-function signature="close()" allow-thread="yes" />
    <modify-function signature="flush()" allow-thread="yes" />
    <modify-function signature="seek(qint64)" allow-thread="yes" />
    <modify-function signature="remove()" allow-thread="yes" />
    <modify-function signature="copy(const QString&amp;)" allow-thread="yes" />
    <modify-function signature="rename(const QString&amp;)" allow-thread="yes" />
    <modify-function signature="link(const QString&amp;)" allow-thread="yes" />
    <modify-function signature="mkdir(const QString&amp;, bool)const" allow-thread="yes" />
    <modify-function signature="rmdir(const QString&amp;, bool)const" allow-thread="yes" />
    <modify-function signature="write(const char*, qint64)" allow-thread="yes" />

    <modify-function signature="beginEntryList(QFlags&lt;QDir::Filter>,const QStringList&amp;)">
      <modify-argument index="return">
        <define-ownership class="native" owner="c++"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="unmap(uchar*)">
        <modify-argument index="1">
            <replace-type modified-type="PyBuffer"/>
        </modify-argument>
        <inject-code>
        uchar* ptr = (uchar*)Shiboken::Buffer::getPointer(%PYARG_1);
        %RETURN_TYPE %0 = %CPPSELF.%FUNCTION_NAME(ptr);
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
        </inject-code>
    </modify-function>
    <modify-function signature="map(qint64,qint64,QFile::MemoryMapFlags)">
        <modify-argument index="return">
            <replace-type modified-type="PyObject"/>
        </modify-argument>
        <inject-code>
            %PYARG_0 = Shiboken::Buffer::newObject(%CPPSELF.%FUNCTION_NAME(%1, %2, %3), %2, Shiboken::Buffer::ReadWrite);
        </inject-code>
    </modify-function>

    <modify-function signature="read(char*, qint64)" allow-thread="yes">
        <inject-code class="target">
            QByteArray ba;
            ba.resize(%2);
            %CPPSELF.%FUNCTION_NAME(ba.data(), ba.size());
            %PYARG_0 = PyBytes_FromStringAndSize(ba.constData(), ba.size());
        </inject-code>
        <modify-argument index="1">
            <remove-argument />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="PyObject"/>
            <conversion-rule class="native">
                %RETURN_TYPE %out;
                if (!Shiboken::String::check(%PYARG_0)) {
                    %out = -1;
                } else {
                    %out = PyBytes_GET_SIZE((PyObject*)%PYARG_0);
                    memcpy(%1, PyBytes_AS_STRING((PyObject*)%PYARG_0), %out);
                }
            </conversion-rule>
        </modify-argument>
    </modify-function>
    <modify-function signature="readLine(char*, qint64)" allow-thread="yes">
        <inject-code class="target">
            QByteArray ba;
            ba.resize(%2);
            %CPPSELF.%FUNCTION_NAME(ba.data(), ba.size());
            %PYARG_0 = PyBytes_FromStringAndSize(ba.constData(), ba.size());
        </inject-code>
        <modify-argument index="1">
            <remove-argument />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="PyObject"/>
            <conversion-rule class="native">
                %RETURN_TYPE %out;
                if (!Shiboken::String::check(%PYARG_0)) {
                    %out = -1;
                } else {
                    %out = PyBytes_GET_SIZE((PyObject*)%PYARG_0);
                    memcpy(%1, PyBytes_AS_STRING((PyObject*)%PYARG_0), %out);
                }
            </conversion-rule>
        </modify-argument>
    </modify-function>
  </object-type>
  <object-type name="QProcess">
    <enum-type name="ExitStatus"/>
    <enum-type name="ProcessChannel"/>
    <enum-type name="ProcessChannelMode"/>
    <enum-type name="ProcessError"/>
    <enum-type name="ProcessState"/>

    <modify-function signature="waitForStarted(int)" allow-thread="yes"/>
    <modify-function signature="waitForBytesWritten(int)" allow-thread="yes"/>
    <modify-function signature="waitForFinished(int)" allow-thread="yes"/>
    <modify-function signature="readAllStandardOutput()" allow-thread="yes"/>
    <modify-function signature="readAllStandardError()" allow-thread="yes"/>
    <modify-function signature="execute(QString, QStringList)" allow-thread="yes"/>
    <modify-function signature="execute(QString)" allow-thread="yes"/>
    <modify-function signature="startDetached(QString,QStringList,QString,qint64*)">
        <modify-argument index="4">
            <remove-argument />
        </modify-argument>
        <modify-argument index="return">
            <replace-type modified-type="(retval, pid)"/>
        </modify-argument>
        <inject-code class="target" position="beginning">
        qint64 pid;
        %RETURN_TYPE retval = %TYPE::%FUNCTION_NAME(%1, %2, %3, &amp;pid);
        %PYARG_0 = PyTuple_New(2);
        PyTuple_SET_ITEM(%PYARG_0, 0, %CONVERTTOPYTHON[%RETURN_TYPE](retval));
        PyTuple_SET_ITEM(%PYARG_0, 1, %CONVERTTOPYTHON[qint64](pid));
        </inject-code>
    </modify-function>
    <!-- Function removed because on windows it returns a win32 specific structure -->
    <modify-function signature="pid()const" remove="all" />
    <add-function signature="pid()" return-type="long">
        <inject-code>
            long result;
            #ifdef WIN32
                _PROCESS_INFORMATION* procInfo = %CPPSELF.%FUNCTION_NAME();
                result = procInfo ? procInfo->dwProcessId : 0;
            #else
                result = %CPPSELF.%FUNCTION_NAME();
            #endif
            %PYARG_0 = %CONVERTTOPYTHON[long](result);
        </inject-code>
    </add-function>
    <!--### Obsolete in 4.3-->
    <modify-function signature="setReadChannelMode(QProcess::ProcessChannelMode)" remove="all"/>
    <modify-function signature="readChannelMode()const" remove="all"/>
    <!-- ### -->
  </object-type>
  <object-type name="QSignalMapper" />

  <object-type name="QCoreApplication">
    <enum-type name="Encoding" />
    <enum-type identified-by-value="ApplicationFlags" since="4.8" revision="4800"/>
    <extra-includes>
      <include file-name="QStringList" location="global"/>
      <include file-name="QTranslator" location="global"/>
    </extra-includes>
    <!-- constructor documentation -->
    <inject-documentation format="target" mode="append">
.. class:: QCoreApplication(args)

    Constructs a Qt kernel application. Kernel applications are applications
    without a graphical user interface. These type of applications are used
    at the console or as server processes.

    The *args* argument is processed by the application, and made available
    in a more convenient form by the :meth:`~QCoreApplication.arguments()`
    method.
    </inject-documentation>
    <add-function signature="QCoreApplication(PySequence)">
        <inject-code>
            QCoreApplication_constructor(%PYSELF, args, &amp;%0);
        </inject-code>
    </add-function>
    <!-- blocking functions -->
    <modify-function signature="processEvents(QFlags&lt;QEventLoop::ProcessEventsFlag&gt;, int)" allow-thread="yes"/>
    <modify-function signature="processEvents(QFlags&lt;QEventLoop::ProcessEventsFlag&gt;)" allow-thread="yes"/>
    <modify-function signature="flush()" allow-thread="yes"/>
    <modify-function signature="sendEvent(QObject*, QEvent*)" allow-thread="yes"/>
    <modify-function signature="sendPostedEvents(QObject*, int)" allow-thread="yes"/>
    <modify-function signature="sendPostedEvents()" allow-thread="yes"/>
    <modify-function signature="instance()">
      <inject-code class="target">
        QCoreApplication* app = QCoreApplication::instance();
        PyObject* pyApp = Py_None;
        if (app) {
            pyApp = reinterpret_cast&lt;PyObject*&gt;(Shiboken::BindingManager::instance().retrieveWrapper(app));
            if (!pyApp)
                pyApp = %CONVERTTOPYTHON[QCoreApplication*](app); // this will keep app live after python exit (extra ref)
        }
        %PYARG_0 = pyApp;
        Py_XINCREF(%PYARG_0);
      </inject-code>
    </modify-function>

    <modify-function signature="exec()" rename="exec_" allow-thread="yes"/>
    <!-- ### Obsolete -->
    <modify-function signature="argc()" remove="all"/>
    <modify-function signature="argv()" remove="all"/>
    <!-- ### -->
    <modify-function signature="notify(QObject*,QEvent*)" allow-thread="yes">
      <modify-argument index="2" invalidate-after-use="yes"/>
    </modify-function>
    <modify-function signature="QCoreApplication(int &amp;, char  **)" access="private"/>
    <inject-code class="native" file="glue/qcoreapplication_init.cpp" position="beginning" />
    <modify-function signature="postEvent(QObject*,QEvent*)">
      <modify-argument index="2">
        <define-ownership owner="c++"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="postEvent(QObject*,QEvent*, int)">
      <modify-argument index="2">
        <define-ownership owner="c++"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="winEventFilter(MSG*, long*)">
      <modify-argument index="2">
        <remove-argument />
        <conversion-rule class="native">
            long *%out = new long;
            %out = 0;
        </conversion-rule>
      </modify-argument>
      <modify-argument index="return">
        <replace-type modified-type="PyObject"/>
        <conversion-rule class="native">
            %RETURN_TYPE %out = false;
            if (PySequence_Check(%PYARG_0) &amp;&amp; (PySequence_Size(%PYARG_0) == 2)) {
                Shiboken::AutoDecRef pyResult(PySequence_GetItem(%PYARG_0, 0));
                %out = %CONVERTTOCPP[bool](pyResult);
            }
        </conversion-rule>
      </modify-argument>
      <inject-code position="end">
      %PYARG_0 = PyTuple_New(2);
      PyTuple_SET_ITEM(%PYARG_0, 0, %CONVERTTOPYTHON[%RETURN_TYPE](%0));
      PyTuple_SET_ITEM(%PYARG_0, 1, %CONVERTTOPYTHON[long](*result_out));
      delete result_out;
      </inject-code>
    </modify-function>
  </object-type>
  <object-type name="QSettings">
    <enum-type name="Format"/>
    <enum-type name="Scope"/>
    <enum-type name="Status"/>
    <extra-includes>
      <include file-name="QStringList" location="global"/>
    </extra-includes>
    <!--### Obsolete in 4.3-->
    <modify-function signature="setSystemIniPath(const QString&amp;)" remove="all"/>
    <modify-function signature="setUserIniPath(const QString&amp;)" remove="all"/>
    <!--### Obsolete in 4.3-->
    <modify-function signature="iniCodec()const">
      <modify-argument index="return">
        <define-ownership class="target" owner="default"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="value(const QString&amp;, const QVariant&amp;)const">
        <inject-documentation mode="append" format="target">
            .. warning:: QSettings.value can return different types (QVariant types) depending on the platform it's running on, so the safest way to use it is always casting the result to the desired type, e.g.: int(settings.value("myKey"))
        </inject-documentation>
    </modify-function>
  </object-type>
  <object-type name="QEvent"  polymorphic-id-expression="%1-&gt;type() == QEvent::None">
    <enum-type name="Type" extensible="yes" />
  </object-type>
  <object-type name="QChildEvent" polymorphic-id-expression="%1-&gt;type() == QEvent::ChildAdded || %1-&gt;type() == QEvent::ChildPolished || %1-&gt;type() == QEvent::ChildRemoved">
    <modify-field name="c" read="false" write="false"/>
    <modify-function signature="child() const">
      <modify-argument index="return">
         <define-ownership class="target" owner="default"/>
      </modify-argument>
    </modify-function>
  </object-type>
  <object-type name="QTimerEvent" polymorphic-id-expression="%1-&gt;type() == QEvent::Timer" />
  <object-type name="QDynamicPropertyChangeEvent" polymorphic-id-expression="%1-&gt;type() == QEvent::DynamicPropertyChange" />

  <template name="stream_read_method">
      %RETURN_TYPE _cpp_result;
      (*%CPPSELF) &gt;&gt; _cpp_result;
      %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](_cpp_result);
  </template>

  <template name="stream_write_method">
      (*%CPPSELF) &lt;&lt; %1;
  </template>

  <object-type name="QDataStream" stream="yes">
    <enum-type name="FloatingPointPrecision" since="4.6"/>
    <enum-type name="Status"/>
    <enum-type name="Version"/>
    <enum-type name="ByteOrder"/>
    <extra-includes>
      <include file-name="QtCore/QtCore" location="global"/>
    </extra-includes>

    <modify-function signature="setDevice(QIODevice*)">
      <modify-argument index="1">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>

    <!-- ### Replaced by write<TYPE> methods -->
    <modify-function signature="operator&gt;&gt;(qint8&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(bool&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(quint8&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(qint16&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(quint16&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(qint32&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(quint32&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(qint64&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(quint64&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(float&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(double&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(char*&amp;)" remove="all"/>
    <!-- ### -->

    <!-- ### Replaced by read<TYPE> methods -->
    <modify-function signature="operator&lt;&lt;(qint8)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(bool)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(quint8)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(qint16)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(quint16)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(qint32)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(quint32)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(qint64)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(quint64)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(float)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(double)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(const char*)" remove="all"/>
    <!-- ### -->
    <add-function signature="operator&lt;&lt;(const QString&amp;)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeQString(const QString&amp;)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readQString()" return-type="QString">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeQChar(const QChar&amp;)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readQChar()" return-type="QChar">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeQStringList(const QStringList&amp;)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readQStringList()" return-type="QStringList">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeQVariant(const QVariant&amp;)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readQVariant()" return-type="QVariant">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <modify-function signature="readRawData(char*,int)">
        <modify-argument index="1">
            <remove-argument />
        </modify-argument>
        <inject-code class="target">
            QByteArray data;
            data.resize(%2);
            int result = %CPPSELF.%FUNCTION_NAME(data.data(), data.size());
            if (result == -1) {
                Py_INCREF(Py_None);
                %PYARG_0 = Py_None;
            } else {
                %PYARG_0 = PyBytes_FromStringAndSize(data.data(), result);
            }
        </inject-code>
    </modify-function>
    <modify-function signature="writeRawData(const char*,int)">
        <modify-argument index="2">
            <remove-argument />
        </modify-argument>
        <inject-code class="target">
            int r = %CPPSELF.%FUNCTION_NAME(%1, Shiboken::String::len(%PYARG_1));
            %PYARG_0 = %CONVERTTOPYTHON[int](r);
        </inject-code>
    </modify-function>

    <!-- Extra functions for primitive type handling -->
    <add-function signature="readBool()" return-type="bool">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readInt8()" return-type="qint8">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readUInt8()" return-type="quint8">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readUInt16()" return-type="quint16">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readInt16()" return-type="qint16">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readInt32()" return-type="qint32">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readUInt32()" return-type="quint32">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readInt64()" return-type="qint64">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readUInt64()" return-type="quint64">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readFloat()" return-type="float">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readDouble()" return-type="qreal">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>
    <add-function signature="readString()" return-type="QString">
        <inject-code class="target" position="end">
            <insert-template name="stream_read_method"/>
        </inject-code>
    </add-function>

    <add-function signature="writeBool(bool)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeInt8(qint8)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeUInt8(quint8)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeUInt16(quint16)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeInt16(qint16)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeInt32(qint32)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeUInt32(quint32)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeInt64(qint64)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeUInt64(quint64)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeFloat(float)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeDouble(qreal)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>
    <add-function signature="writeString(QString)">
        <inject-code class="target" position="end">
            <insert-template name="stream_write_method"/>
        </inject-code>
    </add-function>

    <!-- ### deprecated method -->
    <modify-function signature="readBytes(char*&amp;,uint&amp;)" remove="all"/>
    <modify-function signature="writeBytes(const char*,uint)" remove="all" />
  </object-type>
  <object-type name="QFSFileEngine">
    <extra-includes>
      <include file-name="QDateTime" location="global"/>
    </extra-includes>
  </object-type>
  <value-type name="QTextStreamManipulator" default-constructor="QTextStreamManipulator(0, 0)">
    <modify-function signature="exec(QTextStream &amp;)" rename="exec_"/>
  </value-type>
  <object-type name="QTextStream" stream="yes">
    <enum-type name="FieldAlignment"/>
    <enum-type name="NumberFlag" flags="NumberFlags"/>
    <enum-type name="RealNumberNotation"/>
    <enum-type name="Status"/>
    <!-- Removed because it expect QString to be mutable -->
    <modify-function signature="QTextStream(QString*,QFlags&lt;QIODevice::OpenModeFlag&gt;)" remove="all"/>
    <!-- Removed because we use the non-const version -->
    <modify-function signature="QTextStream(const QByteArray&amp;, QFlags&lt;QIODevice::OpenModeFlag&gt;)" remove="all"/>

    <!-- Removed because it expect QString to be mutable -->
    <modify-function signature="setString(QString*,QFlags&lt;QIODevice::OpenModeFlag&gt;)" remove="all"/>

    <modify-function signature="operator&lt;&lt;(const void*)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(float)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(qlonglong)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(qulonglong)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(signed short)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(signed int)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(QBool)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(unsigned int)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(unsigned short)" remove="all"/>
    <modify-function signature="operator&lt;&lt;(const char*)" remove="all"/>

    <modify-function signature="operator&gt;&gt;(char*)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(char&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(float&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(double&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(qlonglong&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(qulonglong&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(signed long&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(signed int&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(signed short&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(unsigned long&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(unsigned int&amp;)" remove="all"/>
    <modify-function signature="operator&gt;&gt;(unsigned short&amp;)" remove="all"/>
    <!-- Removed because it expect QChar to be mutable -->
    <modify-function signature="operator&gt;&gt;(QChar&amp;)" remove="all"/>
    <!-- Removed because it expect QString to be mutable -->
    <modify-function signature="operator&gt;&gt;(QString&amp;)" remove="all"/>

    <modify-function signature="string()const">
      <modify-argument index="return">
        <!--<replace-type modified-type="QString" />-->
        <conversion-rule class="target">
        QString&amp; res = *%0;
        %PYARG_0 = %CONVERTTOPYTHON[QString](res);
        </conversion-rule>
      </modify-argument>
    </modify-function>

    <modify-function signature="flush()" allow-thread="yes"/>
    <modify-function signature="read(qint64)" allow-thread="yes"/>
    <modify-function signature="readLine(qint64)" allow-thread="yes"/>
    <modify-function signature="readAll()" allow-thread="yes"/>
  </object-type>
  <object-type name="QSystemSemaphore">
    <enum-type name="AccessMode"/>
    <enum-type name="SystemSemaphoreError"/>
  </object-type>
  <namespace-type name="QtConcurrent" target-type="class">
    <enum-type name="ReduceOption" flags="ReduceOptions"/>
    <extra-includes>
      <include file-name="qtconcurrentreducekernel.h" location="global"/>
      <include file-name="qtconcurrentthreadengine.h" location="global"/>
    </extra-includes>
  </namespace-type>
  <object-type name="QThreadPool">
    <modify-function signature="start(QRunnable*, int)">
      <modify-argument index="1">
        <parent index="this" action="add" />
      </modify-argument>
    </modify-function>
    <modify-function signature="tryStart(QRunnable*)">
      <modify-argument index="1">
        <parent index="this" action="add" />
      </modify-argument>
    </modify-function>

    <modify-function signature="globalInstance()" >
      <inject-code position="end">
        Shiboken::Object::releaseOwnership(%PYARG_0);
      </inject-code>
    </modify-function>
  </object-type>
  <value-type name="QXmlStreamAttribute"/>
  <value-type name="QXmlStreamAttributes">
    <modify-function signature="push_back(QXmlStreamAttribute)" remove="all"/>
    <modify-function signature="pop_back()" remove="all"/>
    <modify-function signature="push_front(QXmlStreamAttribute)" remove="all"/>
    <modify-function signature="pop_front()" remove="all"/>
    <modify-function signature="toList() const" remove="all"/>
    <modify-function signature="fromList(const QList&lt;QXmlStreamAttribute&gt; &amp;)" remove="all"/>
    <modify-function signature="operator+=(QVector&lt;QXmlStreamAttribute&gt;)" remove="all" />
  </value-type>
  <value-type name="QXmlStreamNamespaceDeclaration"/>
  <value-type name="QXmlStreamNotationDeclaration"/>
  <value-type name="QXmlStreamEntityDeclaration"/>
  <object-type name="QXmlStreamReader">
    <enum-type name="Error"/>
    <enum-type name="TokenType"/>
    <enum-type name="ReadElementTextBehaviour" since="4.6"/>
  </object-type>
  <object-type name="QXmlStreamWriter">
    <!-- Removed because it expect QString to be mutable -->
    <modify-function signature="QXmlStreamWriter(QString *)" remove="all" />
    <modify-function signature="codec()const">
      <modify-argument index="return">
        <define-ownership class="target" owner="default"/>
      </modify-argument>
    </modify-function>
  </object-type>
  <value-type name="QModelIndex" hash-function="qHash">
    <modify-function signature="internalPointer()const">
        <inject-code class="target" position="beginning">
            <insert-template name="return_internal_pointer" />
        </inject-code>
    </modify-function>
    <modify-function signature="model()const">
      <modify-argument index="return">
        <define-ownership class="target" owner="default"/>
      </modify-argument>
    </modify-function>
  </value-type>

  <value-type name="QGenericArgument">
    <include file-name="qobjectdefs.h" location="global" />
  </value-type>

  <value-type name="QGenericReturnArgument">
    <include file-name="qobjectdefs.h" location="global" />
  </value-type>

  <value-type name="QMetaMethod">
    <enum-type name="Access"/>
    <enum-type name="MethodType"/>
    <!-- This isn't part of Qt public API -->
    <modify-function signature="attributes()const" remove="all" />
  </value-type>
  <object-type name="QMetaObject">
    <enum-type name="Call"/>
    <include file-name="qobjectdefs.h" location="global" />
    <!-- This isn't part of Qt public API -->
    <modify-function signature="connect(const QObject*, int, const QObject*, int, int, int*)" remove="all" />
  </object-type>
  <value-type name="QMetaProperty" >
    <!-- This isn't part of Qt public API -->
    <modify-function signature="enclosingMetaObject()const" remove="all" />
  </value-type>
  <value-type name="QMetaClassInfo">
    <!-- This isn't part of Qt public API -->
    <modify-function signature="enclosingMetaObject()const" remove="all" />
  </value-type>
  <value-type name="QMetaEnum">
    <!-- This isn't part of Qt public API -->
    <modify-function signature="enclosingMetaObject()const" remove="all" />
  </value-type>
  <!-- From Qt4.6 -->
  <object-type name="QAbstractAnimation" since="4.6">
    <enum-type name="DeletionPolicy"/>
    <enum-type name="Direction"/>
    <enum-type name="State"/>
  </object-type>

  <object-type name="QAbstractState" since="4.6">
    <modify-function signature="machine() const">
        <modify-argument index="this">
            <parent index="return" action="add"/>
        </modify-argument>
    </modify-function>
  </object-type>

  <object-type name="QAbstractTransition" since="4.6">
    <modify-function signature="QAbstractTransition(QState*)">
      <modify-argument index="1">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="addAnimation(QAbstractAnimation*)">
      <modify-argument index="1">
        <reference-count action="add"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="removeAnimation(QAbstractAnimation*)">
      <modify-argument index="1">
        <reference-count action="remove"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="setTargetState(QAbstractState*)">
      <modify-argument index="1">
        <reference-count action="set"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="targetState() const">
      <modify-argument index="return">
        <reference-count action="set" variable-name="setTargetState(QAbstractState*)1" />
      </modify-argument>
    </modify-function>


    <modify-function signature="targetStates() const">
      <modify-argument index="return">
        <reference-count action="set" variable-name="setTargetState(QAbstractState*)1" />
      </modify-argument>
    </modify-function>


    <modify-function signature="setTargetStates(QList&lt;QAbstractState*&gt;)">
      <modify-argument index="1">
        <reference-count action="set" variable-name="setTargetState(QAbstractState*)1" />
      </modify-argument>
    </modify-function>

  </object-type>

  <object-type name="QAnimationGroup" since="4.6">
    <modify-function signature="addAnimation(QAbstractAnimation*)">
      <modify-argument index="1">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="insertAnimation(int, QAbstractAnimation*)">
      <modify-argument index="2">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="removeAnimation(QAbstractAnimation*)">
      <modify-argument index="1">
        <parent index="this" action="remove"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="takeAnimation(int)">
      <modify-argument index="return">
        <parent index="this" action="remove"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="clear()" >
        <inject-code class="target" position="beginning">
        for(int counter = 0; counter &lt; %CPPSELF.animationCount(); ++counter ) {
            QAbstractAnimation* animation = %CPPSELF.animationAt(counter);
            PyObject* obj = %CONVERTTOPYTHON[QAbstractAnimation*](animation);
            Shiboken::Object::setParent(NULL, obj);
            Py_DECREF(obj);
        }
        %CPPSELF.clear();
        </inject-code>
    </modify-function>
  </object-type>

  <!-- We will use inject code to implement the function below -->
  <rejection class="QEasingCurve" function-name="setCustomType" />
  <rejection class="QEasingCurve" function-name="customType" />
  <value-type name="QEasingCurve" since="4.6">
    <extra-includes>
      <include file-name="pysideweakref.h" location="global"/>
      <include file-name="glue/qeasingcurve_glue.h" location="local"/>
    </extra-includes>
    <inject-code>
        PySideEasingCurveFunctor::init();
    </inject-code>
    <enum-type name="Type" />
    <add-function signature="setCustomType(PyObject*)">
      <inject-code>
        QEasingCurve::EasingFunction func = PySideEasingCurveFunctor::createCustomFuntion(%PYSELF, %PYARG_1);
        if (func)
            %CPPSELF.%FUNCTION_NAME(func);
      </inject-code>
    </add-function>
    <add-function signature="customType()" return-type="PyObject">
      <inject-code>
        //%FUNCTION_NAME()
        %PYARG_0 = PySideEasingCurveFunctor::callable(%PYSELF);
      </inject-code>
    </add-function>
  </value-type>

  <object-type name="QEventTransition" since="4.6">
    <modify-function signature="QEventTransition(QState*)">
      <modify-argument index="1">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="QEventTransition(QObject*, QEvent::Type, QState*)">
      <modify-argument index="3">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>

  </object-type>

  <object-type name="QFinalState" since="4.6" />

  <object-type name="QHistoryState" since="4.6">
    <enum-type name="HistoryType" />
    <modify-documentation xpath='description/code'>
        &lt;code>machine = QStateMachine()

s1 = new QState()
s11 = new QState(s1)
s12 = new QState(s1)

s1h = QHistoryState(s1)
s1h.setDefaultState(s11)

machine.addState(s1)

s2 = QState()
machine.addState(s2)

button = QPushButton()
# Clicking the button will cause the state machine to enter the child state
# that s1 was in the last time s1 was exited, or the history state's default
# state if s1 has never been entered.
s1.addTransition(button.clicked, s1h)&lt;/code>
    </modify-documentation>
  </object-type>

  <value-type name="QMargins" since="4.6"/>

  <object-type name="QParallelAnimationGroup" since="4.6"/>

  <object-type name="QPauseAnimation" since="4.6"/>

  <value-type name="QProcessEnvironment" since="4.6"/>

  <object-type name="QPropertyAnimation" since="4.6"/>

  <object-type name="QSequentialAnimationGroup" since="4.6"/>

  <object-type name="QSignalTransition" since="4.6">
    <add-function signature="QSignalTransition(PyObject*, QState*)" return-type="QSignalTransition*">
        <modify-argument index="2">
            <replace-default-expression with="0" />
        </modify-argument>
        <inject-code>
            if (PyObject_TypeCheck(%1, &amp;PySideSignalInstanceType)) {
                PyObject* dataSource = PySide::Signal::getObject((PySideSignalInstance*) %PYARG_1);
                Shiboken::AutoDecRef obType(PyObject_Type(dataSource));
                QObject* sender = %CONVERTTOCPP[QObject*](dataSource);
                if (sender) {
                    const char* dataSignature = PySide::Signal::getSignature((PySideSignalInstance*) %PYARG_1);
                    QByteArray signature(dataSignature); // Append SIGNAL flag (2)
                    %0 = new QSignalTransitionWrapper(sender, "2" + signature, %2);
                }
            }
        </inject-code>
    </add-function>
  </object-type>

  <object-type name="QState" since="4.6">
    <enum-type name="ChildMode"/>
    <modify-function signature="addTransition(QAbstractTransition*)">
      <modify-argument index="1">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>

    <modify-function signature="addTransition(QObject*, const char*, QAbstractState*)">
      <modify-argument index="return">
        <parent index="this" action="add"/>
      </modify-argument>
      <inject-code class="target" position="beginning">
      QString signalName(%2);
      if (PySide::SignalManager::registerMetaMethod(%1, signalName.mid(1).toAscii().data(), QMetaMethod::Signal)) {
          QSignalTransition* %0 = %CPPSELF->addTransition(%1, %2, %3);
          %PYARG_0 = %CONVERTTOPYTHON[QSignalTransition*](%0);
      } else {
          Py_INCREF(Py_None);
          %PYARG_0 = Py_None;
      }
      </inject-code>
    </modify-function>
    <modify-function signature="addTransition(QAbstractState*)">
      <modify-argument index="1">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>

    <!-- FIXME: the proper signature for this added function would be something like
         addTransition(PySide.QtCore.Signal, QAbstractState*)
         but that depends on bug #362. -->
    <add-function signature="addTransition(PyObject*, QAbstractState*)" return-type="QSignalTransition*">
      <modify-argument index="return">
        <parent index="this" action="add"/>
      </modify-argument>
      <inject-code class="target" position="beginning">
      // Obviously the label used by the following goto is a very awkward solution,
      // since it refers to a name very tied to the generator implementation.
      // Check bug #362 for more information on this
      // http://bugs.openbossa.org/show_bug.cgi?id=362
      if (!PyObject_TypeCheck(%1, &amp;PySideSignalInstanceType))
          goto Sbk_%TYPEFunc_%FUNCTION_NAME_TypeError;
      PySideSignalInstance* signalInstance = reinterpret_cast&lt;PySideSignalInstance*&gt;(%1);
      QObject* sender = %CONVERTTOCPP[QObject*](PySide::Signal::getObject(signalInstance));
      QSignalTransition* %0 = %CPPSELF->%FUNCTION_NAME(sender, PySide::Signal::getSignature(signalInstance), %2);
      %PYARG_0 = %CONVERTTOPYTHON[QSignalTransition*](%0);
      </inject-code>
    </add-function>

    <modify-function signature="removeTransition(QAbstractTransition*)">
      <modify-argument index="1">
        <parent index="this" action="remove"/>
      </modify-argument>
    </modify-function>
  </object-type>

  <object-type name="QStateMachine" since="4.6">
    <enum-type name="Error"/>
    <enum-type name="EventPriority"/>
    <enum-type name="RestorePolicy"/>

    <value-type name="SignalEvent" since="4.6"/>
    <value-type name="WrappedEvent" since="4.6"/>

    <modify-function signature="addState(QAbstractState *)">
      <modify-argument index="1">
        <parent index="this" action="add"/>
      </modify-argument>
    </modify-function>
    <modify-function signature="removeState(QAbstractState *)">
      <modify-argument index="1">
        <parent index="this" action="remove"/>
      </modify-argument>
    </modify-function>

    <add-function signature="configuration()" return-type="list of QAbstractState" >
        <inject-code class="target" position="beginning">
            %PYARG_0 = PySet_New(0);
            foreach(QAbstractState* abs_state, %CPPSELF.configuration()) {
                    Shiboken::AutoDecRef obj(%CONVERTTOPYTHON[QAbstractState*](abs_state));
                    Shiboken::Object::setParent(self, obj);
                    PySet_Add(%PYARG_0, obj);
            }
        </inject-code>
    </add-function>

    <!-- Replaced by a added function -->
    <modify-function signature="defaultAnimations() const" remove="all"/>
    <add-function signature="defaultAnimations()" return-type="list of QAbstractAnimation" >
        <inject-code class="target" position="beginning">
            %PYARG_0 = PyList_New(0);
            foreach(QAbstractAnimation* abs_anim, %CPPSELF.defaultAnimations()) {
                    Shiboken::AutoDecRef obj(%CONVERTTOPYTHON[QAbstractAnimation*](abs_anim));
                    Shiboken::Object::setParent(self, obj);
                    PyList_Append(%PYARG_0, obj);
            }
        </inject-code>
    </add-function>
  </object-type>

  <object-type name="QVariantAnimation" since="4.6"/>

  <!-- From Qt4.6 ^^^ -->

  <add-function signature="SIGNAL(const char*)" return-type="str">
    <inject-code class="target" position="beginning">
      %PYARG_0 = Shiboken::String::fromFormat("2%s", QMetaObject::normalizedSignature(%1).constData());
    </inject-code>
  </add-function>

  <add-function signature="SLOT(const char*)" return-type="str">
    <inject-code class="target" position="beginning">
      %PYARG_0 = Shiboken::String::fromFormat("1%s", QMetaObject::normalizedSignature(%1).constData());
    </inject-code>
  </add-function>

  <add-function signature="QT_TR_NOOP(PyObject)" return-type="PyObject*">
    <inject-code class="target" position="beginning">
      <insert-template name="return_argument"><replace from="#" to="1" /></insert-template>
    </inject-code>
  </add-function>
  <add-function signature="QT_TR_NOOP_UTF8(PyObject)" return-type="PyObject*">
    <inject-code class="target" position="beginning">
      <insert-template name="return_argument"><replace from="#" to="1" /></insert-template>
    </inject-code>
  </add-function>
  <add-function signature="QT_TRANSLATE_NOOP(PyObject, PyObject)" return-type="PyObject*">
    <inject-code class="target" position="beginning">
      <insert-template name="return_argument"><replace from="#" to="2" /></insert-template>
    </inject-code>
  </add-function>
  <add-function signature="QT_TRANSLATE_NOOP3(PyObject, PyObject, PyObject)" return-type="PyObject*">
    <inject-code class="target" position="beginning">
      <insert-template name="return_argument"><replace from="#" to="2" /></insert-template>
    </inject-code>
  </add-function>
  <add-function signature="QT_TRANSLATE_NOOP_UTF8(PyObject)" return-type="PyObject*">
    <inject-code class="target" position="beginning">
      <insert-template name="return_argument"><replace from="#" to="1" /></insert-template>
    </inject-code>
  </add-function>

  <inject-code class="native" position="beginning">
    extern bool
    qRegisterResourceData(int,
                        const unsigned char *,
                        const unsigned char *,
                        const unsigned char *);

    extern bool
    qUnregisterResourceData(int,
                            const unsigned char *,
                            const unsigned char *,
                            const unsigned char *);
  </inject-code>
  <add-function signature="qRegisterResourceData(int, PyBytes, PyBytes, PyBytes)" return-type="bool">
    <inject-code class="target" position="beginning">
        %RETURN_TYPE %0 = %FUNCTION_NAME(%1, (uchar*)PyBytes_AS_STRING(%PYARG_2),
                                             (uchar*)PyBytes_AS_STRING(%PYARG_3),
                                             (uchar*)PyBytes_AS_STRING(%PYARG_4));
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
    </inject-code>
  </add-function>
  <add-function signature="qUnregisterResourceData(int, PyBytes, PyBytes, PyBytes)" return-type="bool">
    <inject-code class="target" position="beginning">
        %RETURN_TYPE %0 = %FUNCTION_NAME(%1, (uchar*)PyBytes_AS_STRING(%PYARG_2),
                                             (uchar*)PyBytes_AS_STRING(%PYARG_3),
                                             (uchar*)PyBytes_AS_STRING(%PYARG_4));
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
    </inject-code>
  </add-function>

  <object-type name="QFactoryInterface"/>
  <object-type name="QRunnable"/>

  <object-type name="QPluginLoader"/>

  <suppress-warning text="Unable to decide type of property: 'QLibrary::LoadHints' in class 'QPluginLoader'" />
  <suppress-warning text="enum '_ISalnum' does not have a type entry or is not an enum" />
  <suppress-warning text="enum 'Qt::Initialization' does not have a type entry or is not an enum" />
  <suppress-warning text="visibility of function '*' modified in class '*'"/>
  <suppress-warning text="hiding of function '*' in class '*'"/>
  <suppress-warning text="namespace '*' does not have a type entry"/>
  <suppress-warning text="Shadowing: QObject::parent() const and QAbstractItemModel::parent() const"/>
  <suppress-warning text="namespace '*' for enum 'QtMsgType' is not declared"/>
  <suppress-warning text="horribly broken type 'imaxdiv_t'"/>
  <suppress-warning text="horribly broken type '__off64_t'"/>
  <suppress-warning text="horribly broken type 'div_t'"/>
  <suppress-warning text="horribly broken type 'fd_set*'"/>
  <suppress-warning text="horribly broken type 'ldiv_t'"/>
  <suppress-warning text="horribly broken type 'lldiv_t'"/>
  <suppress-warning text="signal '*' in class '*' is overloaded."/>
  <suppress-warning text="enum 'enum_3' does not have a type entry or is not an enum"/>
  <suppress-warning text="Shadowing: QFile::fileName() const and QTemporaryFile::fileName() const"/>
  <suppress-warning text="unhandled enum value: ~0u in Qt::GestureType"/>
  <suppress-warning text="unhandled enum value: (sizeof(void*)&lt;&lt;3) in QSysInfo::Sizes"/>
  <suppress-warning text="unmatched enum ~0u"/>
  <suppress-warning text="unmatched enum (sizeof(void*)&lt;&lt;3)"/>
  <suppress-warning text="signature 'setCustomType(float)' for function modification in 'QEasingCurve' not found. Possible candidates: setCustomType(double) in QEasingCurve"/>
  <suppress-warning text="enum 'enum_4' does not have a type entry or is not an enum" />
  <suppress-warning text="enum 'enum_5' does not have a type entry or is not an enum" />
  <suppress-warning text="enum 'FP_NORMAL' does not have a type entry or is not an enum" />
  <suppress-warning text="Shadowing: *" />
  <!-- this enum is defined on Qt global header but only used in QtDeclarative module -->
  <suppress-warning text="enum 'QML_HAS_ATTACHED_PROPERTIES' does not have a type entry or is not an enum" />

  <!-- this enum is defined on Qt global header but only used in QtGui module -->
  <suppress-warning text="enum 'PM_MessageBoxHeight' does not have a type entry or is not an enum" />

  <!-- this function only exists on Windows -->
  <suppress-warning text="signature 'winEventFilter(MSG*,long*)' for function modification in 'QCoreApplication' not found. Possible candidates:*"/>

  <!-- this is necessary to avoid warning on other modules -->
  <suppress-warning text="signature 'operator*(QByteArray,const char*)' for function modification in 'QByteArray' not found. Possible candidates: *"/>
  <suppress-warning text="signature 'operator+(QByteArray,QString)' for function modification in 'QByteArray' not found. Possible candidates: *"/>

  <!-- This enum is intenaly used -->
  <suppress-warning text="enum 'PM_CbaIconHeight' does not have a type entry or is not an enum" />

  <!-- TODO: this need be removed -->
  <suppress-warning text="skipping function '*', unmatched return type '*'"/>
  <suppress-warning text="skipping function '*', unmatched parameter type '*'"/>


</typesystem>
