<?xml version="1.0"?>
<!--
    This file is part of PySide project.
    Copyright (C) 2009-2010 Nokia Corporation and/or its subsidiary(-ies).
    Contact: PySide team <contact@pyside.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-->
<typesystem>
    <template name="replace_child">
        $CHILD_TYPE* oldChild = %CPPSELF.$FUNCTION_GET_OLD();
        if (oldChild) {
            Shiboken::AutoDecRef pyChild(%CONVERTTOPYTHON[$CHILD_TYPE*](oldChild));
            Shiboken::Object::setParent(NULL, pyChild);
        }
        Shiboken::Object::setParent(%PYSELF, $PYARG);
    </template>

    <!-- Templates to fix bool* parameters -->
    <template name="fix_bool*">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(&amp;ok_);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_args,bool*">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;ok_);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_arg,bool*,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%1, &amp;ok_, %3);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_bool*,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(&amp;ok_, %2);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_bool*,arg,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(&amp;ok_, %2, %3);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_bool*,arg,arg,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(&amp;ok_, %2, %3, %4);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_arg,arg,arg,arg,arg,arg,arg,bool*,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%1, %2, %3, %4, %5, %6, %7, &amp;ok_, %9);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_arg,arg,arg,arg,arg,arg,bool*,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%1, %2, %3, %4, %5, %6, &amp;ok_, %8);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_arg,arg,arg,arg,arg,bool*,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%1, %2, %3, %4, %5, &amp;ok_, %7);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="get_slice">
        %TYPE* sequence;
        Py_ssize_t start, end;
        Py_ssize_t len = %CPPSELF->count();

        if (_i1 &gt; len)
            start = len;
        else if (_i1 &lt; 0)
            start = 0;
        else
            start = _i1;

        if (_i2 &gt; len)
            end = len;
        else if (_i2 &lt; 0)
           end = 0;
        else
           end = _i2;

        sequence = new %TYPE();
        for (Py_ssize_t i = start; i &lt; end; i++)
            sequence->append(%CPPSELF->at(i));

        return %CONVERTTOPYTHON[%TYPE](*sequence);
    </template>

    <template name="fix_args,QRectF*">
        QRectF rect_;
        %CPPSELF.%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;rect_);
        %PYARG_0 = %CONVERTTOPYTHON[QRectF](rect_);
    </template>

    <template name="fix_args,QRect*">
        QRect rect_;
        %CPPSELF.%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;rect_);
        %PYARG_0 = %CONVERTTOPYTHON[QRect](rect_);
    </template>

    <template name="fix_char*">
        char val_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(&amp;val_);
        %PYARG_0 = Shiboken::makeTuple(retval_, val_);
    </template>

    <template name="fix_int*,int*,int*,int*">
        int a, b, c, d;
        %CPPSELF.%FUNCTION_NAME(&amp;a, &amp;b, &amp;c, &amp;d);
        %PYARG_0 = Shiboken::makeTuple(a, b, c, d);
    </template>
    <template name="fix_qreal*,qreal*,qreal*,qreal*">
        qreal a, b, c, d;
        %CPPSELF.%FUNCTION_NAME(&amp;a, &amp;b, &amp;c, &amp;d);
        %PYARG_0 = Shiboken::makeTuple(a, b, c, d);
    </template>

    <template name="fix_int*,int*,int*,int*,int*">
        int a, b, c, d, e;
        %CPPSELF.%FUNCTION_NAME(&amp;a, &amp;b, &amp;c, &amp;d, &amp;e);
        %PYARG_0 = Shiboken::makeTuple(a, b, c, d, e);
    </template>
    <template name="fix_qreal*,qreal*,qreal*,qreal*,qreal*">
        qreal a, b, c, d, e;
        %CPPSELF.%FUNCTION_NAME(&amp;a, &amp;b, &amp;c, &amp;d, &amp;e);
        %PYARG_0 = Shiboken::makeTuple(a, b, c, d, e);
    </template>
    <template name="read_wrapper">
        PySide::AutoArrayPointer&lt;char&gt; _data(%2);
        qint64 _size = %CPPSELF.%FUNCTION_NAME(_data, %2);
        if (_size > 0)
            %PYARG_0 = %CONVERTTOPYTHON[QByteArray](QByteArray(_data, _size));
        else
            %PYARG_0 = %CONVERTTOPYTHON[QByteArray](QByteArray());
    </template>
    <template name="fix_return_args,int*">
        RETURNTYPE _ret;
        int _arg;
        _ret = %CPPSELF.%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;_arg);
        %PYARG_0 = Shiboken::makeTuple(_ret, _arg);
    </template>

    <template name="fix_virtual_method_return_value_and_bool*">
        Shiboken::AutoDecRef _py_ret_(PySequence_GetItem(%PYARG_0, 0));
        Shiboken::AutoDecRef _py_ok_(PySequence_GetItem(%PYARG_0, 1));
        %RETURN_TYPE %out = %CONVERTTOCPP[%RETURN_TYPE](_py_ret_);
        *%2 = %CONVERTTOCPP[bool](_py_ok_);
    </template>

    <template name="fix_arg,int*,int*">
        %RETURN_TYPE _ret;
        int a, b;
        _ret = %CPPSELF.%FUNCTION_NAME(%1, &amp;a, &amp;b);
        %PYARG_0 = Shiboken::makeTuple(_ret, a, b);
    </template>

    <template name="return_QString">
        %PYARG_0 = %CONVERTTOPYTHON[QString](%1);
    </template>

    <template name="return_tuple_QValidator_QString_int">
        %RETURN_TYPE retval_ = %RETURN_TYPE(%CPPSELF.%FUNCTION_NAME(%1, %2));
        %PYARG_0 = Shiboken::makeTuple(retval_, %1, %2);
    </template>

    <template name="return_for_QFileDialog">
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%1, %2, %3, %4, %5);
        %PYARG_0 = Shiboken::makeTuple(retval_, %4);
    </template>
   <template name="set_qapp_parent_for_orphan">
        SbkObject* _pySelf = reinterpret_cast&lt;SbkObject*&gt;(%PYARG_0);
        if (!Shiboken::Object::hasParentInfo(_pySelf))
            Shiboken::Object::setParent(%CONVERTTOPYTHON[QApplication*](qApp), %PYARG_0);
    </template>
    <!-- templates for __reduce__ -->
    <template name="reduce_code">
        PyObject *type = PyObject_Type(%PYSELF);
        PyObject *args = NULL;
        args = Py_BuildValue("%REDUCE_FORMAT", %REDUCE_ARGS);
        %PYARG_0 = Py_BuildValue("(NN)", type, args);
    </template>
    <template name="reduce_code_matrix">
        QList&lt; %MATRIX_TYPE &gt; cppArgs;
        %MATRIX_TYPE data[%MATRIX_SIZE];
        %CPPSELF.copyDataTo(data);
        int matrixSize = %MATRIX_SIZE;
        for(int size=0; size &lt; matrixSize; size++)
            cppArgs.append(data[size]);

        PyObject *type = PyObject_Type(%PYSELF);
        PyObject *args = Py_BuildValue("(N)", %CONVERTTOPYTHON[QList&lt;%MATRIX_TYPE&gt; ](cppArgs));
        %PYARG_0 = Py_BuildValue("(NN)", type, args);
    </template>

    <!-- Matrix Aux functions -->
    <template name="matrix_constructor">
        if (PySequence_Size(%PYARG_1) == %SIZE) {
            Shiboken::AutoDecRef fast(PySequence_Fast(%PYARG_1, "Fail to parse sequnce on %TYPE constructor."));
            qreal values[%SIZE];
            for(int i=0; i &lt; %SIZE; i++) {
                PyObject *pv = PySequence_Fast_GET_ITEM(fast.object(), i);
                values[i] = %CONVERTTOCPP[qreal](pv);
            }
            %0 = new %TYPE(values);
        }
    </template>

    <template name="matrix_data_function">
        const qreal* data = %CPPSELF.constData();
        PyObject *pyData = PyTuple_New(%MATRIX_SIZE);
        if (data) {
            for(int i=0; i &lt; %MATRIX_SIZE; i++)
                PyTuple_SET_ITEM(pyData, i, %CONVERTTOPYTHON[qreal](data[i]));
        }
        return pyData;
    </template>

    <template name="matrix_fill_function">
        qreal value = %CONVERTTOCPP[qreal](%PYARG_1);
        %CPPSELF.fill(value);
    </template>

    <template name="matrix_transposed_function">
        return %CONVERTTOPYTHON[%TRANSPOSED_TYPE](%CPPSELF.transposed());
    </template>

    <!-- Replace '#' for the argument number you want. -->
    <template name="return_argument">
        Py_INCREF(%PYARG_#);
        %PYARG_0 = %PYARG_#;
    </template>

</typesystem>

