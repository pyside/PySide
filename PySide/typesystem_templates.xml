<?xml version="1.0"?>
<typesystem>
    <template name="replace_child">
        $CHILD_TYPE* oldChild = %CPPSELF.$FUNCTION_GET_OLD();
        if (oldChild) {
            Shiboken::AutoDecRef pyChild(%CONVERTTOPYTHON[$CHILD_TYPE*](oldChild));
            Shiboken::setParent(NULL, pyChild);
        }
        Shiboken::setParent(%PYSELF, $PYARG);
    </template>

    <!-- Templates to fix bool* parameters -->
    <template name="fix_bool*">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(&amp;ok_);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_args,bool*">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;ok_);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_arg,bool*,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%1, &amp;ok_, %3);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_bool*,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(&amp;ok_, %2);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_bool*,arg,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(&amp;ok_, %2, %3);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_bool*,arg,arg,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(&amp;ok_, %2, %3, %4);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_arg,arg,arg,arg,arg,arg,arg,bool*,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%1, %2, %3, %4, %5, %6, %7, &amp;ok_, %9);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_arg,arg,arg,arg,arg,arg,bool*,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%1, %2, %3, %4, %5, %6, &amp;ok_, %8);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="fix_arg,arg,arg,arg,arg,bool*,arg">
        bool ok_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%1, %2, %3, %4, %5, &amp;ok_, %7);
        %PYARG_0 = Shiboken::makeTuple(retval_, ok_);
    </template>
    <template name="get_slice">
        %TYPE* sequence;
        Py_ssize_t start, end;
        Py_ssize_t len = %CPPSELF->count();

        if (_i1 &gt; len)
            start = len;
        else if (_i1 &lt; 0)
            start = 0;
        else
            start = _i1;

        if (_i2 &gt; len)
            end = len;
        else if (_i2 &lt; 0)
           end = 0;
        else
           end = _i2;

        sequence = new %TYPE();
        for (Py_ssize_t i = start; i &lt; end; i++)
            sequence->append(%CPPSELF->at(i));

        return %CONVERTTOPYTHON[%TYPE](*sequence);
    </template>

    <template name="fix_args,QRectF*">
        QRectF rect_;
        %CPPSELF.%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;rect_);
        %PYARG_0 = %CONVERTTOPYTHON[QRectF](rect_);
    </template>

    <template name="fix_args,QRect*">
        QRect rect_;
        %CPPSELF.%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;rect_);
        %PYARG_0 = %CONVERTTOPYTHON[QRect](rect_);
    </template>

    <template name="fix_char*">
        char val_;
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(&amp;val_);
        %PYARG_0 = Shiboken::makeTuple(retval_, val_);
    </template>

    <template name="fix_int*,int*,int*,int*">
        int a, b, c, d;
        %CPPSELF.%FUNCTION_NAME(&amp;a, &amp;b, &amp;c, &amp;d);
        %PYARG_0 = Shiboken::makeTuple(a, b, c, d);
    </template>
    <template name="fix_qreal*,qreal*,qreal*,qreal*">
        qreal a, b, c, d;
        %CPPSELF.%FUNCTION_NAME(&amp;a, &amp;b, &amp;c, &amp;d);
        %PYARG_0 = Shiboken::makeTuple(a, b, c, d);
    </template>

    <template name="fix_int*,int*,int*,int*,int*">
        int a, b, c, d, e;
        %CPPSELF.%FUNCTION_NAME(&amp;a, &amp;b, &amp;c, &amp;d, &amp;e);
        %PYARG_0 = Shiboken::makeTuple(a, b, c, d, e);
    </template>
    <template name="fix_qreal*,qreal*,qreal*,qreal*,qreal*">
        qreal a, b, c, d, e;
        %CPPSELF.%FUNCTION_NAME(&amp;a, &amp;b, &amp;c, &amp;d, &amp;e);
        %PYARG_0 = Shiboken::makeTuple(a, b, c, d, e);
    </template>
    <template name="read_wrapper">
        char _data[%2];
        qint64 _size = %CPPSELF.%FUNCTION_NAME(_data, %2);
        if (_size > 0)
            %PYARG_0 = %CONVERTTOPYTHON[QByteArray](QByteArray(_data, _size));
        else
            %PYARG_0 = %CONVERTTOPYTHON[QByteArray](QByteArray());
    </template>
    <template name="fix_return_args,int*">
        RETURNTYPE _ret;
        int _arg;
        _ret = %CPPSELF.%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;_arg);
        %PYARG_0 = Shiboken::makeTuple(_ret, _arg);
    </template>

    <template name="fix_virtual_method_return_value_and_bool*">
        AutoDecRef _py_ret_(PySequence_GetItem(%PYARG_0, 0));
        AutoDecRef _py_ok_(PySequence_GetItem(%PYARG_0, 1));
        %RETURN_TYPE %out = %CONVERTTOCPP[%RETURN_TYPE](_py_ret_);
        *%2 = %CONVERTTOCPP[bool](_py_ok_);
    </template>

    <template name="fix_arg,int*,int*">
        %RETURN_TYPE _ret;
        int a, b;
        _ret = %CPPSELF.%FUNCTION_NAME(%1, &amp;a, &amp;b);
        %PYARG_0 = Shiboken::makeTuple(_ret, a, b);
    </template>

    <template name="return_QString">
        %PYARG_0 = %CONVERTTOPYTHON[QString](%1);
    </template>

    <template name="return_tuple_QValidator_QString_int">
        %RETURN_TYPE retval_ = %RETURN_TYPE(%CPPSELF.%FUNCTION_NAME(%1, %2));
        %PYARG_0 = Shiboken::makeTuple(retval_, %1, %2);
    </template>

    <template name="return_for_QFileDialog">
        %RETURN_TYPE retval_ = %CPPSELF.%FUNCTION_NAME(%1, %2, %3, %4, %5);
        %PYARG_0 = Shiboken::makeTuple(retval_, %4);
    </template>
</typesystem>

